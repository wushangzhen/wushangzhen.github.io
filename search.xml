<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2019/02/15/dynamic-programing/"/>
      <url>/2019/02/15/dynamic-programing/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>动态规划是必须要掌握的算法，去年上过关于动态规划的专题班，但是没有更深一步的总结，这一轮刷题的时候还是要深入的总结一下动态规划的常见题型，常见的动态规划算法有两种，一种top down主要代表就是记忆化搜索，另一种是bottomup这种其实就是递推公式类型的，先把LeetCode上关于动态规划的常见题型总结一下。</p><h1 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h1><p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Longest Palindromic Substring</a><br>区间型动态规划,空间复杂度O(n^2), 也可以用字符串扩展的方法实现O(1)空间复杂度</p><p>dp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        int n = sc.length;</span><br><span class="line">        boolean[][] dp = new boolean[n][n];</span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = true;</span><br><span class="line">            for (int j = i; j &gt;= 0; j--) &#123;</span><br><span class="line">                if ((j + 2 &gt; i || dp[j + 1][i - 1]) &amp;&amp; sc[i] == sc[j]) &#123;</span><br><span class="line">                    dp[j][i] = true;</span><br><span class="line">                    if (i - j + 1 &gt; max) &#123;</span><br><span class="line">                        start = j;</span><br><span class="line">                        max = i - j + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字符串扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        int n = sc.length;</span><br><span class="line">        int start = -1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int len1 = expand(sc, i, i);</span><br><span class="line">            int len2 = expand(sc, i, i + 1);</span><br><span class="line">            if (len1 &gt; max) &#123;</span><br><span class="line">                start = i - len1 / 2;</span><br><span class="line">                max = len1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (len2 &gt; max) &#123;</span><br><span class="line">                start = i - (len2 - 1) / 2;</span><br><span class="line">                max = len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">    int expand(char[] sc, int i, int j) &#123;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; j &lt; sc.length) &#123;</span><br><span class="line">            if (sc[i] == sc[j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return j - i - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Longest-Palindromic-Subsequence"><a href="#Longest-Palindromic-Subsequence" class="headerlink" title="Longest Palindromic Subsequence"></a>Longest Palindromic Subsequence</h1><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">Longest Palindromic Subsequence</a><br>区间型动态规划, 这题求的是subsequence，代表这个区间内最长的子序列，可以不以i结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[][] dp = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = 1; // 初始化</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                dp[j][i] = Math.max(dp[j][i - 1], dp[j + 1][i]); // 先比较dp[j][i - 1], dp[j + 1][i]取最大值</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[j][i] = Math.max(dp[j + 1][i - 1] + 2, dp[j][i]); // 如果相同就加上。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h1><p><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="noopener">Regular Expression Matching</a><br>双序列型动态规划，这个题属于记忆化搜索，也是dp的一种，我们要做的事，建立一个visited数组和results数组记录结构，用两根指针来记录遍历位置，注意终止条件, 建议做十遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int m = p.length();</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        char[] pc = p.toCharArray();</span><br><span class="line">        boolean[][] visited = new boolean[n][m];</span><br><span class="line">        boolean[][] results = new boolean[n][m];</span><br><span class="line">        return helper(0, 0, sc, pc, visited, results);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean helper(int ps, int pp, char[] sc, char[] pc, boolean[][] visited, boolean[][] results) &#123;</span><br><span class="line">        if (pp == pc.length) &#123;</span><br><span class="line">            return ps == sc.length; // it has to be end</span><br><span class="line">        &#125;</span><br><span class="line">        if (ps == sc.length) &#123;</span><br><span class="line">            return isAllStar(pp, pc); // has to follow the pattern</span><br><span class="line">        &#125;</span><br><span class="line">        if (visited[ps][pp]) &#123;</span><br><span class="line">            return results[ps][pp];</span><br><span class="line">        &#125;</span><br><span class="line">        boolean match = false;</span><br><span class="line">        if (pp + 1 &lt; pc.length &amp;&amp; pc[pp + 1] == &apos;*&apos;) &#123; // regard a* as a part </span><br><span class="line">            match = helper(ps, pp + 2, sc, pc, visited, results) || ((sc[ps] == pc[pp] || pc[pp] == &apos;.&apos;) &amp;&amp; helper(ps + 1, pp, sc, pc, visited, results));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            match = (pc[pp] == sc[ps] || pc[pp] == &apos;.&apos;) &amp;&amp; helper(ps + 1, pp + 1, sc, pc, visited, results);</span><br><span class="line">        &#125;// it is the only way to make it right</span><br><span class="line">        visited[ps][pp] = true;</span><br><span class="line">        results[ps][pp] = match;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                     </span><br><span class="line">    boolean isAllStar(int pp, char[] pc) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = pp; i &lt; pc.length; i++) &#123;</span><br><span class="line">            if (count % 2 == 0) &#123;</span><br><span class="line">                if (pc[i] == &apos;*&apos;) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (pc[i] == &apos;*&apos;) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count % 2 == 0;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a>Wildcard Matching</h1><p><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="noopener">Wildcard Matching</a><br>这个题比上一个题要简单一点，但是大致思路是一样的，记忆化搜索，bugfree<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int m = p.length();</span><br><span class="line">        boolean[][] visited = new boolean[n][m];</span><br><span class="line">        boolean[][] results = new boolean[n][m];</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        char[] pc = p.toCharArray();</span><br><span class="line">        return helper(0, 0, sc, pc, visited, results);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean helper(int p1, int p2, char[] sc, char[] pc, boolean[][] visited, boolean[][] results) &#123;</span><br><span class="line">        if (p2 == pc.length) &#123;</span><br><span class="line">            return p1 == sc.length;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p1 == sc.length) &#123;</span><br><span class="line">            return isAllStar(p2, pc);</span><br><span class="line">        &#125;</span><br><span class="line">        if (visited[p1][p2]) &#123;</span><br><span class="line">            return results[p1][p2];</span><br><span class="line">        &#125;</span><br><span class="line">        boolean match = false;</span><br><span class="line">        if (pc[p2] == &apos;*&apos;) &#123;</span><br><span class="line">            match = helper(p1 + 1, p2, sc, pc, visited, results) || helper(p1, p2 + 1, sc, pc, visited, results);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            match = ((sc[p1] == pc[p2] || pc[p2] == &apos;?&apos;) &amp;&amp; helper(p1 + 1, p2 + 1, sc, pc, visited, results));</span><br><span class="line">        &#125;</span><br><span class="line">        visited[p1][p2] = true;</span><br><span class="line">        results[p1][p2] = match;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isAllStar(int p, char[] pc) &#123;</span><br><span class="line">        for (int i = p; i &lt; pc.length; i++) &#123;</span><br><span class="line">            if (pc[i] != &apos;*&apos;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Longest-Valid-Parentheses"><a href="#Longest-Valid-Parentheses" class="headerlink" title="Longest Valid Parentheses"></a>Longest Valid Parentheses</h1><p><a href="https://leetcode.com/problems/longest-valid-parentheses/description/" target="_blank" rel="noopener">Longest Valid Parentheses</a><br>序列型动态规划，注意递推条件，遍历，如果遇到 ( 或者 j = i - dp[i - 1] - 1 &lt; 0 或者 sc[j] == )都continue掉，代表以i-1结尾的字符不能构成valid parenthesis。其他的都是dp[i] = 2 + dp[i - 1] + dp[j];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestValidParentheses(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int j = i - dp[i - 1] - 2;</span><br><span class="line">            if (s.charAt(i - 1) == &apos;(&apos; || j &lt; 0 || s.charAt(j) == &apos;)&apos;) &#123;</span><br><span class="line">                dp[i] = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] = dp[i - 1] + dp[j] + 2;</span><br><span class="line">                res = Math.max(dp[i], res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h1><p><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">Edit Distance</a><br>这个题是双序列型动态规划, 三种情况分别算，初始条件搞清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] 表示word1前i个变为word2前j个所需的操作数。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int n = word1.length();</span><br><span class="line">        int m = word2.length();</span><br><span class="line">        int[][] dp = new int[n + 1][m + 1];</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= m; j++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    dp[i][j] = j;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (j == 0) &#123;</span><br><span class="line">                    dp[i][j] = i;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1]; // 不用改变</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1; // replace</span><br><span class="line">                &#125; </span><br><span class="line">                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j]); // add</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i][j]); // delete</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用滚动数组优化空间复杂度O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int n = word1.length();</span><br><span class="line">        int m = word2.length();</span><br><span class="line">        int[][] dp = new int[2][m + 1];</span><br><span class="line">        int old = 0;</span><br><span class="line">        int cur = 1; // rolling array</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            old = cur;</span><br><span class="line">            cur = 1 - cur;</span><br><span class="line">            for (int j = 0; j &lt;= m; j++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    dp[cur][j] = j;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (j == 0) &#123;</span><br><span class="line">                    dp[cur][j] = i;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[cur][j] = dp[old][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[cur][j] = dp[old][j - 1] + 1;</span><br><span class="line">                &#125; </span><br><span class="line">                dp[cur][j] = Math.min(dp[old][j] + 1, dp[cur][j]);</span><br><span class="line">                dp[cur][j] = Math.min(dp[cur][j - 1] + 1, dp[cur][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cur][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Scramble-String"><a href="#Scramble-String" class="headerlink" title="Scramble String"></a>Scramble String</h1><p><a href="https://leetcode.com/problems/scramble-string/description/" target="_blank" rel="noopener">Scramble String</a><br>记忆化搜索，分段递归， 但是这个方法效率很低，下次可以看一个比较快的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;String, Boolean&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">    public boolean isScramble(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s1.equals(s2)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(s1 + &quot;#&quot; + s2)) &#123;</span><br><span class="line">            return memo.get(s1 + &quot;#&quot; + s2);</span><br><span class="line">        &#125;</span><br><span class="line">        if (s1.length() == 1) &#123;</span><br><span class="line">            return s1.charAt(0) == s2.charAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s1.length();</span><br><span class="line">        // great</span><br><span class="line">        // eatgr</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123; // 不能 i &lt;= n 这样的话总是会判断s1 和 s2不能重复</span><br><span class="line">            if ((isScramble(s1.substring(0, i), s2.substring(0, i)) </span><br><span class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(i)))</span><br><span class="line">               || (isScramble(s1.substring(0, i), s2.substring(n - i)) </span><br><span class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(0, n - i)))) &#123;</span><br><span class="line">                memo.put(s1 + &quot;#&quot; + s2, true);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.put(s1 + &quot;#&quot; + s2, false);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a>Decode Ways</h1><p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Decode Ways</a><br>经典题，有很多corner case， 比如100 230等等，主要是以0相关的。如果遍历到这个数为0，需要向前看一位，如果这个位==1或者==2，就是合法的，否则continue;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numDecodings(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        if (s.charAt(0) == &apos;0&apos;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            if (s.charAt(i - 1) == &apos;0&apos;) &#123;</span><br><span class="line">                if (s.charAt(i - 2) == &apos;1&apos; || s.charAt(i - 2) == &apos;2&apos;) &#123;</span><br><span class="line">                    dp[i] = dp[i - 2];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (s.charAt(i - 2) == &apos;1&apos; || (s.charAt(i - 2) == &apos;2&apos; &amp;&amp; s.charAt(i - 1) &lt; &apos;7&apos;)) &#123;</span><br><span class="line">                dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h1><p><a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Unique Binary Search Trees</a><br>卡特兰树，<a href="http://www.cnblogs.com/grandyang/p/4299608.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System Design 8 Map Reduce</title>
      <link href="/2019/02/14/system-design-8/"/>
      <url>/2019/02/14/system-design-8/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>现在mapreduce是大数据工作的敲门砖，非常热门，面试的时候有可能也会考到具体的概念，系统设计更要准备一下。</p><hr><h1 id="Word-Count"><a href="#Word-Count" class="headerlink" title="Word Count"></a>Word Count</h1><p>普通wordcount = hashmap + for循环<br>优点：代码简单<br>缺点：一台机器，慢，内存大小受限</p><p>优化：多台机器for循环，拆分成多块，分别统计，然后合并。<br>缺点：一台机器合并的时候会有瓶颈bottle neck.</p><p>优化：采用并行合并(Map Reduce)</p><ol><li>机器划分(层次的依赖结构，时间上可能慢)</li><li>key划分(更好)<br>Map负责拆分，reduce负责合并。<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/whole%20steps.png?raw=true" alt="结构图"></li></ol><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ol><li>input 输入文件</li><li>split 系统帮我们把文件平均分到各个机器上</li><li>Map 实现代码</li><li>传输整理，系统帮忙</li><li>Reduce实现代码</li><li>output 设定输出文件</li></ol><h2 id="Where-To-Aggregation"><a href="#Where-To-Aggregation" class="headerlink" title="Where To Aggregation"></a>Where To Aggregation</h2><p>聚集操作要reduce来做，如果在split中做，内存可能不够</p><h2 id="Transfer-And-Trim"><a href="#Transfer-And-Trim" class="headerlink" title="Transfer And Trim"></a>Transfer And Trim</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Word-Count-Structure.png?raw=true" alt="传输整理详细过程"></p><h2 id="How-Many-Mechines"><a href="#How-Many-Mechines" class="headerlink" title="How Many Mechines?"></a>How Many Mechines?</h2><p>It depends. 一般1000map，1000reduce</p><h2 id="Pros-And-Cons-For-Adding-Mechines"><a href="#Pros-And-Cons-For-Adding-Mechines" class="headerlink" title="Pros And Cons For Adding Mechines"></a>Pros And Cons For Adding Mechines</h2><p>Pros: 速度增加<br>Cons: 机器启动时间长<br>一般reduce操作的上限是key的数量</p><p><a href="https://www.lintcode.com/problem/word-count-map-reduce/description" target="_blank" rel="noopener">Word Count</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of OutputCollector:</span><br><span class="line"> * class OutputCollector&lt;K, V&gt; &#123;</span><br><span class="line"> *     public void collect(K key, V value);</span><br><span class="line"> *         // Adds a key/value pair to the output buffer</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class WordCount &#123;</span><br><span class="line"></span><br><span class="line">    public static class Map &#123;</span><br><span class="line">        public void map(String key, String value, OutputCollector&lt;String, Integer&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, int value);</span><br><span class="line">            StringTokenizer tok = new StringTokenizer(value);</span><br><span class="line">            while (tok.hasMoreTokens())&#123;</span><br><span class="line">                String word = tok.nextToken();</span><br><span class="line">                output.collect(word, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Reduce &#123;</span><br><span class="line">        public void reduce(String key, Iterator&lt;Integer&gt; values,</span><br><span class="line">                           OutputCollector&lt;String, Integer&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, int value);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            while(values.hasNext())&#123;</span><br><span class="line">                sum += values.next();</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key,sum);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Build-Inverted-Index"><a href="#Build-Inverted-Index" class="headerlink" title="Build Inverted Index"></a>Build Inverted Index</h1><p>举例：<br>0: deer, build<br>1: deer, apple<br>转化为：<br>deer: 0, 1<br>build: 0<br>apple: 1<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Inverted%20Index.png?raw=true" alt="结构"><br><a href="https://www.lintcode.com/problem/inverted-index-map-reduce/description" target="_blank" rel="noopener">Inverted Index</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of OutputCollector:</span><br><span class="line"> * class OutputCollector&lt;K, V&gt; &#123;</span><br><span class="line"> *     public void collect(K key, V value);</span><br><span class="line"> *         // Adds a key/value pair to the output buffer</span><br><span class="line"> * &#125;</span><br><span class="line"> * Definition of Document:</span><br><span class="line"> * class Document &#123;</span><br><span class="line"> *     public int id;</span><br><span class="line"> *     public String content;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class InvertedIndex &#123;</span><br><span class="line"></span><br><span class="line">    public static class Map &#123;</span><br><span class="line">        public void map(String _, Document value,</span><br><span class="line">                        OutputCollector&lt;String, Integer&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, int value);</span><br><span class="line">            StringTokenizer tokenizer = new StringTokenizer(value.content);</span><br><span class="line">            while (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String word = tokenizer.nextToken();</span><br><span class="line">                output.collect(word, value.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Reduce &#123;</span><br><span class="line">        public void reduce(String key, Iterator&lt;Integer&gt; values,</span><br><span class="line">                           OutputCollector&lt;String, List&lt;Integer&gt;&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, List&lt;Integer&gt; value);</span><br><span class="line">            List&lt;Integer&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">            int left = -1;</span><br><span class="line">            while (values.hasNext()) &#123;</span><br><span class="line">                int now = values.next();</span><br><span class="line">                if (left != now) &#123;</span><br><span class="line">                    results.add(now);</span><br><span class="line">                &#125;</span><br><span class="line">                left = now;</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Anagram"><a href="#Anagram" class="headerlink" title="Anagram"></a>Anagram</h1><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Anagram.png?raw=true" alt="结构"><br><a href="https://www.lintcode.com/problem/anagram-map-reduce/description" target="_blank" rel="noopener">Anagram</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of OutputCollector:</span><br><span class="line"> * class OutputCollector&lt;K, V&gt; &#123;</span><br><span class="line"> *     public void collect(K key, V value);</span><br><span class="line"> *         // Adds a key/value pair to the output buffer</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Anagram &#123;</span><br><span class="line"></span><br><span class="line">    public static class Map &#123;</span><br><span class="line">        public void map(String key, String value,</span><br><span class="line">                        OutputCollector&lt;String, String&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, String value);</span><br><span class="line">            StringTokenizer tokenizer = new StringTokenizer(value);</span><br><span class="line">            while (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String word = tokenizer.nextToken();</span><br><span class="line">                char[] sc = word.toCharArray();</span><br><span class="line">                Arrays.sort(sc);</span><br><span class="line">                output.collect(new String(sc), word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Reduce &#123;</span><br><span class="line">        public void reduce(String key, Iterator&lt;String&gt; values,</span><br><span class="line">                           OutputCollector&lt;String, List&lt;String&gt;&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, List&lt;String&gt; value);</span><br><span class="line">            List&lt;String&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">            while (values.hasNext()) &#123;</span><br><span class="line">                results.add(values.next());</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Design-Map-Reduce-System"><a href="#Design-Map-Reduce-System" class="headerlink" title="Design Map Reduce System"></a>Design Map Reduce System</h1><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Map%20Reduce%20Design.png?raw=true" alt="结构"> </p><h2 id="Steps-1"><a href="#Steps-1" class="headerlink" title="Steps"></a>Steps</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/whole%20process.png?raw=true" alt="Steps"></p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q/A"></a>Q/A</h2><ol><li>Mapper 和 Reducer的工作顺序<br> 先Mapper, 再Reducer</li><li>Mapper, Reducer挂了怎么办<br> 重新分配机器</li><li>Reducer中key很多怎么办<br> 加一个random后缀，类似shared key</li><li>Input和Output放在哪<br> GFS</li><li>Local Disk上面的mapper output data 有没有必要保存在GFS上<br> 没有，丢了重做就好</li><li>Mapper 和 Reducer可以在一台机器吗<br> 设计不大好，两种操作都需要预处理，所以两个机器比较好</li></ol>]]></content>
      
      
      <categories>
          
          <category> SystemDesign </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Computer System 1 - Elf Info Reader</title>
      <link href="/2019/02/14/computer-system-elf/"/>
      <url>/2019/02/14/computer-system-elf/</url>
      
        <content type="html"><![CDATA[<h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><h2 id="stat"><a href="#stat" class="headerlink" title="stat()"></a>stat()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;    </span><br><span class="line">#include &lt;sys/stat.h&gt;   </span><br><span class="line">int stat(</span><br><span class="line">　　const char *filename    //文件或者文件夹的路径</span><br><span class="line">　　, struct stat *buf      //获取的信息保存在内存中</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>把文件信息存到stat的结构体指针中, 成功return 0, 失败return -1</p><hr><h2 id="struct-stat"><a href="#struct-stat" class="headerlink" title="struct stat"></a>struct stat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct stat  </span><br><span class="line">&#123;   </span><br><span class="line">    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/  </span><br><span class="line">    ino_t       st_ino;     /* inode number -inode节点号*/    </span><br><span class="line">    mode_t      st_mode;    /* protection -保护模式?*/    </span><br><span class="line">    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/    </span><br><span class="line">    uid_t       st_uid;     /* user ID of owner -user id*/    </span><br><span class="line">    gid_t       st_gid;     /* group ID of owner - group id*/    </span><br><span class="line">    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/    </span><br><span class="line">    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/    </span><br><span class="line">    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/    </span><br><span class="line">    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/    </span><br><span class="line">    time_t      st_atime;   /* time of last access -最近存取时间*/    </span><br><span class="line">    time_t      st_mtime;   /* time of last modification -最近修改时间*/    </span><br><span class="line">    time_t      st_ctime;   /* time of last status change - */    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常用的是 st_size 文件的大小, 修改时间等</p><hr><h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><p><strong>将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值, 块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作, 其返回值为指向S的指针</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">void *memset(void *s,int ch, unsigned n);</span><br><span class="line"></span><br><span class="line">memset(&amp;elfData, 0, sizeof(elfData));</span><br><span class="line">// elfData 里面的指针也可以直接赋值成null</span><br></pre></td></tr></table></figure></p><p>用来清空或重置或初始化</p><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *path, int access, int mode)；</span><br></pre></td></tr></table></figure><ul><li>返回文件句柄, return -1 返回失败 由于第三个参数mode只有当access为O_CREAT的时候才有效，因此open的函数实现是一个可变参数函数</li><li>每个文件都属于自己的句柄，例如标准输入是0，标准输出是1，标准出错是2。</li><li>每打开一个文件就会返回句柄来操作这个文件，一般是从3开始，然后4,5,6一直下去。</li><li>close（fd）之后句柄就返回给系统，例如打开一个文件后fd是3，close之后再打开另外一个文件也还是3，但代表的文件不一样了</li><li>access O_RDONLY  1 只读;    O_WRONLY 2  只写;   O_RDWR  4  读写 </li></ul><hr><h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h1><p>这个函数是这个作业的重点，要充分理解这个函数的作用, 有点妈卖批的感觉<br><a href="http://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">man page mmap()</a><br>在这里总结一下</p><ol><li>linux 的系统调用函数，为了让client和server之间的数据交流更快一点实现了内存映射的功能</li><li>一般来讲client和server之间要通过IPC(管道、消息队列)进行访问，数据需要拷贝四次(I/O操作)，输入文件-&gt;server-&gt;IPC-&gt;client-&gt;输出文件, mmap通过映射到内存，实现输入输出文件通过内存沟通, 代替了I/O操作，频繁读写有优势</li><li>将特殊文件进行匿名内存映射，为关联进程提供共享内存空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">       // addr 指定地址，通常设为NULL 或 0, 自动选址</span><br><span class="line">       // length 代表将文件的多大内存存到内存里</span><br><span class="line">       // prot 映射区域的保护方式。可以为以下几种方式的组合：</span><br><span class="line">            PROT_EXEC 映射区域可被执行</span><br><span class="line">            PROT_READ 映射区域可被读取</span><br><span class="line">            PROT_WRITE 映射区域可被写入</span><br><span class="line">            PROT_NONE 映射区域不能存取</span><br><span class="line">       // flags 影响映射区域的各种特性</span><br><span class="line">           MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享</span><br><span class="line">           MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，此区域作的任何修改都不会写回原来的文件内容</span><br><span class="line">       // fd 要映射文件的文件描述符, 文件句柄</span><br><span class="line">       // offset 偏移量，从文件哪个部分开始映射一般设为1</span><br><span class="line">       int munmap(void *addr, size_t length);</span><br><span class="line"></span><br><span class="line">       data = mmap(0, fileStats.st_size, PROT_READ, MAP_SHARED, fileNum, 0);</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define handle_error(msg) \</span><br><span class="line">    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    char *addr;</span><br><span class="line">    int fd;</span><br><span class="line">    struct stat sb;</span><br><span class="line">    off_t offset, pa_offset;</span><br><span class="line">    size_t length;</span><br><span class="line">    ssize_t s;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 3 || argc &gt; 4) &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s file offset [length]\n&quot;, argv[0]);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[1], O_RDONLY);</span><br><span class="line">    if (fd == -1)</span><br><span class="line">        handle_error(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">    if (fstat(fd, &amp;sb) == -1)           /* To obtain file size */</span><br><span class="line">        handle_error(&quot;fstat&quot;);</span><br><span class="line"></span><br><span class="line">    offset = atoi(argv[2]);</span><br><span class="line">    pa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - 1);</span><br><span class="line">        /* offset for mmap() must be page aligned */</span><br><span class="line"></span><br><span class="line">    if (offset &gt;= sb.st_size) &#123;</span><br><span class="line">        fprintf(stderr, &quot;offset is past end of file\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (argc == 4) &#123;</span><br><span class="line">        length = atoi(argv[3]);</span><br><span class="line">        if (offset + length &gt; sb.st_size)</span><br><span class="line">            length = sb.st_size - offset;</span><br><span class="line">                /* Can&apos;t display bytes past end of file */</span><br><span class="line">    &#125; else &#123;    /* No length arg ==&gt; display to end of file */</span><br><span class="line">        length = sb.st_size - offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,</span><br><span class="line">                MAP_PRIVATE, fd, pa_offset);</span><br><span class="line">    if (addr == MAP_FAILED)</span><br><span class="line">        handle_error(&quot;mmap&quot;);</span><br><span class="line"></span><br><span class="line">    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);</span><br><span class="line">    if (s != length) &#123;</span><br><span class="line">        if (s == -1)</span><br><span class="line">            handle_error(&quot;write&quot;);</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, &quot;partial write&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(addr, length + offset - pa_offset);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="ELF-Data-Structure"><a href="#ELF-Data-Structure" class="headerlink" title="ELF Data Structure"></a>ELF Data Structure</h1><p><a href="http://man7.org/linux/man-pages/man5/elf.5.html" target="_blank" rel="noopener">man page for elf data</a><br>可执行文件的结构顺序如下：<br>ELF Header-&gt;Program Header table or Section Header Table or both<br>ELF在起始位置, ELFheader里面有program header 和 section header table的offset</p><h2 id="ELF-Header-Ehdr"><a href="#ELF-Header-Ehdr" class="headerlink" title="ELF Header(Ehdr)"></a>ELF Header(Ehdr)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    unsigned char e_ident[EI_NIDENT];</span><br><span class="line">    uint16_t      e_type;</span><br><span class="line">    uint16_t      e_machine;</span><br><span class="line">    uint32_t      e_version;</span><br><span class="line">    ElfN_Addr     e_entry;</span><br><span class="line">    ElfN_Off      e_phoff;</span><br><span class="line">    ElfN_Off      e_shoff;</span><br><span class="line">    uint32_t      e_flags;</span><br><span class="line">    uint16_t      e_ehsize;</span><br><span class="line">    uint16_t      e_phentsize;</span><br><span class="line">    uint16_t      e_phnum;</span><br><span class="line">    uint16_t      e_shentsize;</span><br><span class="line">    uint16_t      e_shnum;</span><br><span class="line">    uint16_t      e_shstrndx;</span><br><span class="line">&#125; ElfN_Ehdr;</span><br></pre></td></tr></table></figure><p>char == 1 byte == 16 bit </p><ul><li>e_ident: 包含怎么解析这个的信息，数组里面前四个必须是ELFMAG0、ELFMAG1、ELFMAG2、ELFMAG3，可以通过这个判断这个是不是一个ELF文件</li></ul><p>作业中header可以直接使用这个完成copy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(&amp;elfData, data, sizeof(Elf64_Ehdr));</span><br></pre></td></tr></table></figure></p><p>剩下的就是如何完成其他两个table的copy</p><ul><li>e_phentsize: This member holds the size in bytes of one entry in the file’s program header table; all entries are the same size.</li><li>e_phnum: This member holds the number of entries in the program header table.</li><li>e_shentsize: This member holds a sections header’s size in bytes.  A section header is one entry in the section header table;all entries are the same size.</li><li>e_shnum: This member holds the number of entries in the section header table.</li><li>e_phoff: This member holds the program header table’s file offset in bytes.</li><li>e_shoff: This member holds the section header table’s file offset in bytes.</li><li>e_shstrndx: This member holds the section header table index of the entry associated with the section name string table.If the file has no section name string table, this member holds the value SHN_UNDEF.  If the index of section name string table section is larger than or equal to SHN_LORESERVE (0xff00), this member holds SHN_XINDEX (0xffff) and the real index of the section name string table section is held in the sh_link member of the initial entry in section header table.  Otherwise, the sh_link member of the initial entry in section header table contains the value zero.</li></ul><hr><h2 id="Program-Header-Phdr"><a href="#Program-Header-Phdr" class="headerlink" title="Program Header(Phdr)"></a>Program Header(Phdr)</h2><p>An executable or shared object file’s program header table is an array of structures, each describing a segment or other information the system needs to prepare the program for execution.<br>告诉系统如何准备执行这个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t   p_type;</span><br><span class="line">    uint32_t   p_flags;</span><br><span class="line">    Elf64_Off  p_offset;</span><br><span class="line">    Elf64_Addr p_vaddr;</span><br><span class="line">    Elf64_Addr p_paddr;</span><br><span class="line">    uint64_t   p_filesz;</span><br><span class="line">    uint64_t   p_memsz;</span><br><span class="line">    uint64_t   p_align;</span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void *calloc(size_t n, size_t size);</span><br><span class="line">elfData-&gt;programHeader = (Elf64_Phdr*)calloc(elfData-&gt;elfHeader.e_phnum, sizeof(Elf64_Phdr));</span><br><span class="line">有个疑问？sizeof(Elf64_Phdr) == e_phentsize ????</span><br><span class="line">类似malloc(), 不同是calloc已经初始化好了, 适合初始化数组</span><br><span class="line">通过e_phoff 找到起始位置, for循环memcpy</span><br><span class="line">char* pointer_offset = data + ret-&gt;elfHeader.e_phoff;</span><br><span class="line">for (int i = 0; i &lt; ret-&gt;elfHeader.e_phnum; i++) &#123;</span><br><span class="line">    memcpy(&amp;ret-&gt;programHeader[i], pointer_offset, sizeof(Elf64_Phdr));</span><br><span class="line">    pointer_offset += sizeof(Elf64_Phdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Section-Header-Shdr"><a href="#Section-Header-Shdr" class="headerlink" title="Section Header (Shdr)"></a>Section Header (Shdr)</h2><p>A file’s section header table lets one locate all the file’s sections<br>找到文件所有section</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t   sh_name;</span><br><span class="line">    uint32_t   sh_type;</span><br><span class="line">    uint64_t   sh_flags;</span><br><span class="line">    Elf64_Addr sh_addr;</span><br><span class="line">    Elf64_Off  sh_offset;</span><br><span class="line">    uint64_t   sh_size;</span><br><span class="line">    uint32_t   sh_link;</span><br><span class="line">    uint32_t   sh_info;</span><br><span class="line">    uint64_t   sh_addralign;</span><br><span class="line">    uint64_t   sh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><h3 id="Section-Name"><a href="#Section-Name" class="headerlink" title="Section Name"></a>Section Name</h3><p>老师给的数据结构需要存名字，所以在calloc的时候要多分一点内存，宏定义一个NAMEBUFFER = 100</p><ul><li>SHN_LORESERVE: This value specifies the lower bound of the range of reserved indices.</li><li>sh_link: This member holds a section header table index link, whose interpretation depends on the section type.</li><li>sh_name: This member specifies the name of the section.  Its value is an index into the section header string table section, giving the location of a null-terminated string.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int shNameStringIndex; // 找到namestring的index</span><br><span class="line">if (ret-&gt;elfHeader.e_shstrndx &gt;= SHN_LORESERVE) &#123; // 存的地方是不同的</span><br><span class="line">    shNameStringIndex = ret-&gt;sections[0].sectionHeader.sh_link; // 拿到section0 的link, 存在这里</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    shNameStringIndex = ret-&gt;elfHeader.e_shstrndx; // 存在这里 </span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; ret-&gt;elfHeader.e_shnum; i++) &#123;</span><br><span class="line">    memcpy(&amp;ret-&gt;sections[i].sectionHeader, pointer_offset, sizeof(Elf64_Shdr));    </span><br><span class="line">    pointer_offset += ret-&gt;elfHeader.e_shentsize;</span><br><span class="line">&#125;</span><br><span class="line">for (int j = 0; j &lt; ret-&gt;elfHeader.e_shnum; j++) &#123;</span><br><span class="line">    ret-&gt;sections[j].sectionName = strdup(data + ret-&gt;sections[shNameStringIndex].sectionHeader.sh_offset</span><br><span class="line">        + ret-&gt;sections[j].sectionHeader.sh_name); // strdup复制字符串(里面其实是地址)</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Elf Section build done&quot;);</span><br></pre></td></tr></table></figure><h3 id="Symbol-List"><a href="#Symbol-List" class="headerlink" title="Symbol List"></a>Symbol List</h3><p>通过与sectionname的对比找到相应的section index，通过sectionheader的size和Elf64_Sym找到symbol list的size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (symTableIndex &gt; 0) &#123;</span><br><span class="line">   ret-&gt;otherSymbols.size = ret-&gt;sections[symTableIndex].sectionHeader.sh_size / sizeof(Elf64_Sym);</span><br><span class="line">   ret-&gt;otherSymbols.list = (ElfSymbol*)calloc(ret-&gt;otherSymbols.size, sizeof(Elf64_Sym) + NAME_BUFFER);</span><br><span class="line">   ptr = data + ret-&gt;sections[symTableIndex].sectionHeader.sh_offset;</span><br><span class="line">   for (int i = 0; i &lt; ret-&gt;otherSymbols.size; i++) &#123;</span><br><span class="line">       memcpy(&amp;ret-&gt;otherSymbols.list[i].symbol, ptr, sizeof(Elf64_Sym));    </span><br><span class="line">       ptr += sizeof(Elf64_Sym);</span><br><span class="line">       if (ret-&gt;otherSymbols.list[i].symbol.st_name == 0) &#123;</span><br><span class="line">           continue;    </span><br><span class="line">       &#125;</span><br><span class="line">       ret-&gt;otherSymbols.list[i].name = strdup(data + ret-&gt;sections[symTableNameIndex].sectionHeader.sh_offset</span><br><span class="line">           + ret-&gt;otherSymbols.list[i].symbol.st_name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Destroy-ELF-Data"><a href="#Destroy-ELF-Data" class="headerlink" title="Destroy ELF Data"></a>Destroy ELF Data</h1><h2 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(p);</span><br><span class="line">p = NULL;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ComputerSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System Design 7</title>
      <link href="/2019/02/14/system-design-7/"/>
      <url>/2019/02/14/system-design-7/</url>
      
        <content type="html"><![CDATA[<p>http / https 加密效率相对较低<br>rpc<br>protobuf 序列化，持久化，网络传输<br>thrift<br>系统设计 = 逻辑设计 + 架构设计<br>减少server的工作量，让driver report locations<br>为什么rider QPS远小于driver的？<br>rider不需要像司机那样实时汇报位置，原则上只有打车的时候需要汇报位置。即使为了调度车辆需要手机rider位置信息，其频率也是很低的。<br>为什么司机需要主动查trip table去找match自己的ride? 不是depatch模式吗<br>防止推送的信息丢失，因此保险起见在司机report的时候顺便返回给他匹配的trip。一般一个司机在某个时刻只会匹配一个trip，因此开销不大。<br>composite index<br>不能多个index都是范围的查询，效率低<br>数据按什么查询就按什么拆分</p>]]></content>
      
      
      <categories>
          
          <category> SystemDesign </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System Design 6 Distributed System</title>
      <link href="/2019/02/14/system-design-6/"/>
      <url>/2019/02/14/system-design-6/</url>
      
        <content type="html"><![CDATA[<p>很难把pb级别放入内存，也就是hashmap可能不大行, 排序也可能不大行<br>使用外排序:<br>bloom filter 比 hash 所占内存小<br>slave server提供了CPU和内存</p>]]></content>
      
      
      <categories>
          
          <category> SystemDesign </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System Design 5 - Web Crawler &amp; TypeHead</title>
      <link href="/2019/02/14/system-design-5/"/>
      <url>/2019/02/14/system-design-5/</url>
      
        <content type="html"><![CDATA[<h1 id="WebCrawler"><a href="#WebCrawler" class="headerlink" title="WebCrawler"></a>WebCrawler</h1><p>WebCrawler应该是多线程的爬取网页内容的工具, 爬取的网页数量很大并且每周都会有一个循环，这个信息的存储也会很大，通常会用GFS。</p><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Crawler_Structure.png?raw=true" alt="WebCrawler Structure"></p><h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><ul><li>How many web pages? </li><li>How long? </li><li>How Large?</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ul><li>Crawler</li><li>TaskService</li><li>StorageService</li></ul><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul><li>Use db to store tasks</li><li>BigTable to store web pages</li></ul><h2 id="Simple-Crawler"><a href="#Simple-Crawler" class="headerlink" title="Simple Crawler"></a>Simple Crawler</h2><ol><li>input: URL</li><li>Send an HTTP request and grab the content of the news list page</li><li>Extract all news titles from the news list page</li></ol><h2 id="Single-threaded-Web-Crawler"><a href="#Single-threaded-Web-Crawler" class="headerlink" title="Single-threaded Web Crawler"></a>Single-threaded Web Crawler</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/single-thread-web-crawler.png?raw=true" alt="Structure"><br>不断解析不断存储不断加入Queue中<br>producer and consumer model</p><h2 id="MultiThreaded-Web-Crawler-amp-Distributed-Web-Crawler"><a href="#MultiThreaded-Web-Crawler-amp-Distributed-Web-Crawler" class="headerlink" title="MultiThreaded Web Crawler &amp; Distributed Web Crawler"></a>MultiThreaded Web Crawler &amp; Distributed Web Crawler</h2><p>多个webcrawler同时工作。<br>Three different ways to work together:</p><ol><li>sleep</li><li>condition variable</li><li>semaphore<br>但不一定会提高performance。</li><li>context switch cost</li><li>thread port number limitation</li><li>network bottleneck for single machine<br>如果只按照queue的规则的话，那么有可能有些网页无法及时的爬取，导致信息的不均匀。设计tasktable来避免这一点。<br>有tasktable之后可以有一个messageQueue加锁来实现线程安全<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/tasktable.png?raw=true" alt="TaskTable"><br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/webcrawler+tasktable.png?raw=true" alt="Structure"></li></ol><h2 id="How-to-handle-slow-select"><a href="#How-to-handle-slow-select" class="headerlink" title="How to handle slow select"></a>How to handle slow select</h2><p>task table sharding 多个table同时进行，然后需要一个scheduler来进行管理。<br>爬虫的目标不是每个网页只爬一次(要求实时性)的话可能MQ无法保证，因为加到队尾会太长时间再次爬取<br>数据库存网页有没有抓过, task table priority queue timestamp 来看是否抓过, 使用一个db来存储下一次需要抓取的时间<br>这个过程慢一点没关系，offline 不服务用户</p><h2 id="How-to-handle-update-for-failure"><a href="#How-to-handle-update-for-failure" class="headerlink" title="How to handle update for failure"></a>How to handle update for failure</h2><p>Exponential back-off<br>success: crawl after 1 week<br>failure: crawl after 2 weeks<br>failure again: crawl after 4 weeks<br>…<br>保证了效率，不会总去爬失败的网页。</p><h2 id="How-to-handle-dead-cycle"><a href="#How-to-handle-dead-cycle" class="headerlink" title="How to handle dead cycle"></a>How to handle dead cycle</h2><p>One web has so many url, it will only crawl url in sina pages not others.<br>起始网页 seeds 链接多 新闻源网页<br>Use Quota! 为scheduler中每个网页提供一个限量</p><h2 id="Other-key-points"><a href="#Other-key-points" class="headerlink" title="Other key points"></a>Other key points</h2><p>inverted index 搜索引擎关键部分 查询基本不怎么用数据库, 效率低<br>网页之间有很多指向的关系，网页组成的节点<br>crawler 下载所有网页之后丢给GFS(效率大于DB), 拆开文章分成word,<br>inverted index 假的索引，查询引擎(query engine)<br>中文需要断句(word segmentation)<br>英文词态还原 likes-&gt;like<br>viterbi algorithm 分词算法<br>在query engine里做<br>bfs最好,dfs容易stackoverflow<br>crawler 抓完预渲染<br>多线程crawler<br>瓶颈在于加载网页<br>通过网页是否变化来推断timestamp<br>数据库实现队列<br>queue不应该只是先进先出<br>永远不要删数据！！！</p><hr><h1 id="TypeHead"><a href="#TypeHead" class="headerlink" title="TypeHead"></a>TypeHead</h1><h2 id="Scenario-1"><a href="#Scenario-1" class="headerlink" title="Scenario"></a>Scenario</h2><p>DAU 500m<br>Search: 4 <em> 6 </em> 500m = 12b(every user searches 6 times, types 4 letters)<br>QPS = 12b / 86400 = 138k<br>Peak QPS = 138k * 2 = 276k</p><h2 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h2><ol><li>QueryService</li><li>DataCollectionService</li></ol><h2 id="Storage-1"><a href="#Storage-1" class="headerlink" title="Storage"></a>Storage</h2><h3 id="For-QueryService"><a href="#For-QueryService" class="headerlink" title="For QueryService"></a>For QueryService</h3><p>数据库中like操作是非常expensive的，要用trie来进行优化<br>搜索引擎查询最好是key-value<br>Trie hashMap 效率 hashMap高 Trie省空间 性能差异<br>虽然expected time都是O(n)，但是trie的查找会在内存中跳来跳去<br>并不需要全部存完，可以只存top n的Words, 这个trie有in-memory的也有disk serialization的<br>当Trie太大了内存放不下的话，那么就需要把内存中trie的某些部分序列化之后存到磁盘中，要用的时候再反序列化取到内存中<br>一般就算是执行网页中的动态内容也会放在sandbox中的，不用担心会中毒。<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Typehead%20structure.png?raw=true" alt="TypeHead"></p><h3 id="For-DataCollectionService"><a href="#For-DataCollectionService" class="headerlink" title="For DataCollectionService"></a>For DataCollectionService</h3><p>dataCollectionService offline 统计query<br>相当于把query的活分一部分给data collection去做，来加速query<br>从log data里统计信息的，可以用BigTable</p><h2 id="How-to-qualify-this-system"><a href="#How-to-qualify-this-system" class="headerlink" title="How to qualify this system"></a>How to qualify this system</h2><ol><li>response time </li><li>result quality</li></ol><h2 id="How-to-reduce-response-time"><a href="#How-to-reduce-response-time" class="headerlink" title="How to reduce response time"></a>How to reduce response time</h2><ol><li>cache result</li><li>pre-fetch</li></ol><h2 id="What-if-trie-gets-too-large"><a href="#What-if-trie-gets-too-large" class="headerlink" title="What if trie gets too large"></a>What if trie gets too large</h2><p>Sharding trie, 多个queryservice一起工作, 用consistent hashing来决定具体的string在哪个机器上。<br>trie sharding 不能用单词开头sharding 有可能一个上面特别多<br>prefic sharding<br>sharding 和 QPS 有关，和trie、hashmap无关</p><h2 id="How-to-reduce-size-of-log-file"><a href="#How-to-reduce-size-of-log-file" class="headerlink" title="How to reduce size of log file"></a>How to reduce size of log file</h2><p>Probalilistic Logging<br>就是每来一次搜索我就扔一次骰子(随机数)，如果扔到了特定的数字就log， 否则就忽略。<br>每个log文件的保留都要有个概率，比如1/1000，这样就能显著减少file量。</p><h2 id="爬虫的效率不影响搜索引擎的效率么？"><a href="#爬虫的效率不影响搜索引擎的效率么？" class="headerlink" title="爬虫的效率不影响搜索引擎的效率么？"></a>爬虫的效率不影响搜索引擎的效率么？</h2><p>只会影响搜索结果的时效性，但是不会影响到向用户返回结果的效率。</p>]]></content>
      
      
      <categories>
          
          <category> SystemDesign </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System Design 2 Design User System - DataBase &amp; Memcache</title>
      <link href="/2019/02/13/system-design-2/"/>
      <url>/2019/02/13/system-design-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Scenario-and-Services-想一想情景是什么，需要实现什么功能"><a href="#Scenario-and-Services-想一想情景是什么，需要实现什么功能" class="headerlink" title="Scenario and Services (想一想情景是什么，需要实现什么功能)"></a>Scenario and Services (想一想情景是什么，需要实现什么功能)</h1><p><strong>情景决定功能</strong></p><p><strong>A simple one will include these basic functions</strong></p><ol><li>User registration (用户注册) write op</li><li>LogIn (登陆)</li><li>Search for user information (查询) read op</li><li>Store friendship info</li></ol><p><strong>The number of write op and read op will determine the design of system. When we want to design a system common used by user(people). it will have more read op than write op. Vice versa for machine used system.</strong><br><strong>人用的读多写少，机器用的写多读少</strong></p><p><strong>DAU(Daily Active User)</strong><br><strong>QPS(Quries Per Seconds)</strong> 决定数据存储系统的选择<br><strong>一天的时间 86400s</strong> 为了计算方便可以 ~ 100k</p><p><strong>注册，登录，信息修改 QPS 约</strong> </p><ul><li>100M * 0.1 / 86400 ~ 100 </li><li>0.1 = 平均每个用户每天登录+注册+信息修改 </li><li>Peak = 100 * 3 = 300 3 为预估值</li></ul><p><strong>查询的QPS 约</strong></p><ul><li>100 M * 100 / 86400 ~ 100k</li><li>100 = 平均每个用户每天与查询用户信息相关的操作次数(查看好友，发信息，更新消息主页)</li><li>Peak = 100k * 3 = 300 k</li></ul><h2 id="DataBase-Choice-based-by-QPS"><a href="#DataBase-Choice-based-by-QPS" class="headerlink" title="DataBase Choice based by QPS"></a>DataBase Choice based by QPS</h2><ul><li>MySQL —— 1k (relation type)</li><li>MongoDB / Cassandra —— 10k (disk type)</li><li>Redis(数据持久化) / Memcached(非数据持久化) —— 100k ~ 1M (cache type)</li></ul><hr><ul><li>读多写少的系统一定要用cache进行优化</li><li>file system cpu client browser 都有cache</li><li>优化DB查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class UserService:</span><br><span class="line">    </span><br><span class="line">    def getUser(self, user_id):</span><br><span class="line">        user = cache.get(user_id)</span><br><span class="line">        if user:</span><br><span class="line">            return user</span><br><span class="line">        user = database.get(user_id)</span><br><span class="line">        cache.set(user_id, user)</span><br><span class="line">        return user</span><br><span class="line"></span><br><span class="line">    def setUser(self, user) &#123;</span><br><span class="line">        cache.delete(user.id)</span><br><span class="line">        database.set(user)    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Authentication-Service"><a href="#Authentication-Service" class="headerlink" title="Authentication Service"></a>Authentication Service</h2><h3 id="Session-amp-cookie"><a href="#Session-amp-cookie" class="headerlink" title="Session &amp; cookie"></a>Session &amp; cookie</h3><ol><li>用户login之后会创建Session对象（server端）</li><li>返回session_key值到browser</li><li>这个值被browser记录在cookie中</li><li>用户再次访问的时候会带上这个网站上所有的cookie（session_key）</li><li>服务器检测session_key有效就认为用户登录</li></ol><div class="table-container"><table><thead><tr><th></th><th><strong>SessionTable</strong></th><th></th></tr></thead><tbody><tr><td>session key</td><td>string</td><td>hash值 全局唯一 无规律</td></tr><tr><td>user_id</td><td>foreign key</td><td>指向 user table 用来找user</td></tr><tr><td>expired_at</td><td>timeStamp</td><td>什么时候过期</td></tr></tbody></table></div><ul><li>这个table存在哪里都可以的，存在database可以持久一点，cache的话速度快 如果单点故障就让全部用户重新登录就好</li></ul><hr><p><strong>读写都很多怎么办?</strong></p><ol><li>增加机器分摊流量</li><li>使用Redis(cache-through) 读写都快 Memecached(cache-aside)</li></ol><ul><li>cache-aside: DB 和 cache 通过web server 进行沟通 memcached + mysql</li><li>cache-through: server只和cache沟通，cache和DB沟通 redis(DB + Cache)</li></ul><hr><h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><h2 id="FriendShip-Service"><a href="#FriendShip-Service" class="headerlink" title="FriendShip Service"></a>FriendShip Service</h2><ol><li>存为一条信息 查询一次</li><li>存为两条信息 查询两次</li></ol><p><strong>NoSQL很多事都要自己去做，有transaction不能选择NoSQL</strong></p><h3 id="Example-Cassandra"><a href="#Example-Cassandra" class="headerlink" title="Example Cassandra"></a>Example Cassandra</h3><ol><li>row_key: hashKey</li><li>column_key: sorted enable range query 可以是复合值 query(row_key, column_start, column_end)</li><li>value: String 许多信息时 Serialization </li></ol><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/friendship.png?raw=true" alt="alt text" title="Friendship Example"></p><p><strong>user table 用SQL</strong></p><hr><h1 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h1><h2 id="Single-point-failure"><a href="#Single-point-failure" class="headerlink" title="Single point failure"></a>Single point failure</h2><ul><li>数据拆分 Sharding (NoSQL自带， MySQL不带)<br>  按照一定的规则，将数据拆分成不同的部分，保存在不同的机器上<br>  这样就算挂也不会导致网站 100% 不可用</li><li>数据备份 Replica<br>  通常的做法是一式三份(重要的事情“写”三遍)<br>  Replica 同时还能分摊读请求</li></ul><ul><li>vertical sharding 不同数据放到不同机器 </li><li>Horizontal Sharding 重点！！！普通的hash分配数据时添加机器会发生数据大迁移, 这个属于nonconsistent hashing</li></ul>]]></content>
      
      
      <categories>
          
          <category> SystemDesign </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph Theory - BFS &amp; Union Find &amp; Others</title>
      <link href="/2019/02/13/graph/"/>
      <url>/2019/02/13/graph/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本文总结一下graph的题，图的题好多公司喜欢考，比如Google和intuit，还是需要总结一下常见的题的。</p><hr><h1 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a>Course Schedule</h1><p><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Course Schedule</a><br>普通的拓扑排序，建立入度数组，根据每个点的入度值来加入queue中，最后进行判断即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">        int[] degree = new int[numCourses];</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            topo.put(i, new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] pre : prerequisites) &#123;</span><br><span class="line">            topo.get(pre[1]).add(pre[0]);</span><br><span class="line">            degree[pre[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if (degree[i] == 0) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                degree[i]--; // this is important avoid loop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            int temp = q.poll();</span><br><span class="line">            count++;</span><br><span class="line">            List&lt;Integer&gt; list = topo.get(temp);</span><br><span class="line">            for (int item : list) &#123;</span><br><span class="line">                degree[item]--;</span><br><span class="line">                if (degree[item] == 0) &#123;</span><br><span class="line">                    q.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Graph-Valid-Tree"><a href="#Graph-Valid-Tree" class="headerlink" title="Graph Valid Tree"></a>Graph Valid Tree</h1><p><a href="https://leetcode.com/problems/graph-valid-tree/description/" target="_blank" rel="noopener">Graph Valid Tree</a><br>判断是不是valid tree就是要判断存不存在环，并且看root是不是只有一个。判断环可以用UnionFind，判断root的话，先初始化count，如果发生union就减一，这样最后判断count是否为0就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">    int[] father;</span><br><span class="line">    int count;</span><br><span class="line">    public UnionFind(int n) &#123;</span><br><span class="line">        father = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        count = n;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int a) &#123;</span><br><span class="line">        if (father[a] &lt; 0) &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        father[a] = find(father[a]);</span><br><span class="line">        return father[a];</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int a, int b) &#123;</span><br><span class="line">        a = find(a);</span><br><span class="line">        b = find(b);</span><br><span class="line">        if (a != b) &#123;</span><br><span class="line">            if (father[a] &lt; father[b]) &#123;</span><br><span class="line">                father[a] += father[b];</span><br><span class="line">                father[b] = a;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                father[b] += father[a];</span><br><span class="line">                father[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean validTree(int n, int[][] edges) &#123;</span><br><span class="line">        UnionFind uf = new UnionFind(n);</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            int a = uf.find(edge[0]);</span><br><span class="line">            int b = uf.find(edge[1]);</span><br><span class="line">            if (a == b) &#123;</span><br><span class="line">                return false; // 是否有环</span><br><span class="line">            &#125;</span><br><span class="line">            uf.union(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        return uf.count == 1; // 是否root只有一个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Alien-Dictionary"><a href="#Alien-Dictionary" class="headerlink" title="Alien Dictionary"></a>Alien Dictionary</h1><p><a href="https://leetcode.com/problems/alien-dictionary/description/" target="_blank" rel="noopener">Alien Dictionary</a><br>这个题是典型的拓扑排序的问题，先初始化所有的字符，然后根据前后两个单词第一个不一样的字母来建立拓扑关系，然后输出相应的拓扑顺序即可，至少做10遍把。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        if (words == null || words.length == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, List&lt;Character&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; degree = new HashMap&lt;&gt;();</span><br><span class="line">        for (String word : words) &#123; // initialization</span><br><span class="line">            for (Character c : word.toCharArray()) &#123;</span><br><span class="line">                topo.putIfAbsent(c, new ArrayList&lt;&gt;());</span><br><span class="line">                degree.putIfAbsent(c, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = words.length;</span><br><span class="line">        for (int i = 0; i + 1 &lt; n; i++) &#123;</span><br><span class="line">            int len = Math.min(words[i].length(), words[i + 1].length());</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                char c1 = words[i].charAt(j);</span><br><span class="line">                char c2 = words[i + 1].charAt(j);</span><br><span class="line">                if (c1 != c2) &#123;</span><br><span class="line">                    topo.get(c1).add(c2);</span><br><span class="line">                    degree.put(c2, degree.get(c2) + 1); // topo build graph</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Character&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        for (Character c : degree.keySet()) &#123;</span><br><span class="line">            if (degree.get(c) == 0) &#123;</span><br><span class="line">                q.add(c);</span><br><span class="line">                degree.put(c, -1); // this is important</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            char c = q.poll();</span><br><span class="line">            sb.append(c);</span><br><span class="line">            for (char item : topo.get(c)) &#123;</span><br><span class="line">                degree.put(item, degree.get(item) - 1);</span><br><span class="line">                if (degree.get(item) == 0) &#123;</span><br><span class="line">                    q.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.length() == topo.size() ? sb.toString() : &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Minimum-Height-Trees"><a href="#Minimum-Height-Trees" class="headerlink" title="Minimum Height Trees"></a>Minimum Height Trees</h1><p><a href="https://leetcode.com/problems/minimum-height-trees/description/" target="_blank" rel="noopener">Minimum Height Trees</a><br>这个题的意思是找到一个结点然后让它作为root，可以让整个树有最小的高度，通过分析可知，这样的点在树中最多有两个，我们采用剥洋葱的方式，不断去除叶子结点，最后留下的两个或者一个结点就是相应的root，有种bfs的意思，本质还是拓扑排序，根据连接结点的个数来判断是否为leaf结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            res.add(0);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 0 || edges.length == 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            topo.put(i, new HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            topo.get(edge[0]).add(edge[1]);</span><br><span class="line">            topo.get(edge[1]).add(edge[0]); // undirected graph </span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; leaves = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (topo.get(i).size() == 1) &#123;</span><br><span class="line">                leaves.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (n &gt; 2) &#123;</span><br><span class="line">            n -= leaves.size();</span><br><span class="line">            List&lt;Integer&gt; newLeaves = new ArrayList&lt;&gt;();</span><br><span class="line">            for (int leaf : leaves) &#123;</span><br><span class="line">                for (int i : topo.get(leaf)) &#123;</span><br><span class="line">                    topo.get(i).remove(leaf);</span><br><span class="line">                    if (topo.get(i).size() == 1) &#123;</span><br><span class="line">                        newLeaves.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            leaves = newLeaves;</span><br><span class="line">        &#125;</span><br><span class="line">        return leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reconstruct-Itinerary"><a href="#Reconstruct-Itinerary" class="headerlink" title="Reconstruct Itinerary"></a>Reconstruct Itinerary</h1><p><a href="https://leetcode.com/problems/reconstruct-itinerary/description/" target="_blank" rel="noopener">Reconstruct Itinerary</a><br>这个题需要建图然后dfs，backtracking所有的可能，如果出现一个可能就返回结果，能这样的唯一方法就是要设置全局变量，控制回溯的发生，这个题还是要多练一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">    int numOfTicket = 0;</span><br><span class="line">    int n = 0;</span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; findItinerary(String[][] tickets) &#123;</span><br><span class="line">        numOfTicket = tickets.length;</span><br><span class="line">        for (String[] ticket : tickets) &#123;</span><br><span class="line">            topo.putIfAbsent(ticket[0], new LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (String[] ticket : tickets) &#123;</span><br><span class="line">            topo.get(ticket[0]).add(ticket[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (String str : topo.keySet()) &#123;</span><br><span class="line">            Collections.sort(topo.get(str));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(&quot;JFK&quot;);</span><br><span class="line">        dfs(&quot;JFK&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(String start) &#123;</span><br><span class="line">        if (!topo.containsKey(start)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = topo.get(start);</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            String str = list.get(i);</span><br><span class="line">            res.add(str);</span><br><span class="line">            list.remove(i);</span><br><span class="line">            dfs(str);</span><br><span class="line">            if (n == numOfTicket) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">            res.remove(res.size() - 1);</span><br><span class="line">            list.add(i, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Evaluate-Division"><a href="#Evaluate-Division" class="headerlink" title="Evaluate Division"></a>Evaluate Division</h1><p><a href="https://leetcode.com/problems/evaluate-division/description/" target="_blank" rel="noopener">Evaluate Division</a><br>这个题是真的好，是一个带权值的无向图，增加了复杂度，之前没有做过类似的，所以不知道怎么表示边的同时表示权值，所以还是要写个十遍应该就可以了, 注意不光要记录正向也要记录反向，然后dfs即可。真的好题！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; pairs = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;Double&gt;&gt; valuesPair = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; equations.length; i++) &#123;</span><br><span class="line">            String[] equation = equations[i];</span><br><span class="line">            if (!pairs.containsKey(equation[0])) &#123;</span><br><span class="line">                pairs.put(equation[0], new ArrayList&lt;&gt;());</span><br><span class="line">                valuesPair.put(equation[0], new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            if (!pairs.containsKey(equation[1])) &#123;</span><br><span class="line">                pairs.put(equation[1], new ArrayList&lt;&gt;());</span><br><span class="line">                valuesPair.put(equation[1], new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            pairs.get(equation[0]).add(equation[1]);</span><br><span class="line">            pairs.get(equation[1]).add(equation[0]);</span><br><span class="line">            valuesPair.get(equation[0]).add(values[i]);</span><br><span class="line">            valuesPair.get(equation[1]).add(1 / values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        double[] result = new double[queries.length];</span><br><span class="line">        for (int i = 0; i &lt; queries.length; i++) &#123;</span><br><span class="line">            String[] query = queries[i];</span><br><span class="line">            result[i] = dfs(query[0], query[1], pairs, valuesPair, new HashSet&lt;&gt;(), 1.0);</span><br><span class="line">            if (result[i] == 0.0) &#123;</span><br><span class="line">                result[i] = -1.0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private double dfs(String start, String end, Map&lt;String, List&lt;String&gt;&gt; pairs, </span><br><span class="line">                       Map&lt;String, List&lt;Double&gt;&gt; values, Set&lt;String&gt; set, double value) &#123;</span><br><span class="line">        if (set.contains(start)) &#123;</span><br><span class="line">            return 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!pairs.containsKey(start)) &#123;</span><br><span class="line">            return 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (start.equals(end)) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(start);</span><br><span class="line">        List&lt;String&gt; strList = pairs.get(start);</span><br><span class="line">        List&lt;Double&gt; valueList = values.get(start);</span><br><span class="line">        double tmp = 0.0;</span><br><span class="line">        for (int i = 0; i &lt; strList.size(); i++) &#123;</span><br><span class="line">            tmp = dfs(strList.get(i), end, pairs, values, set, value * valueList.get(i));</span><br><span class="line">            if (tmp != 0.0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set.remove(start);</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Redundant-Connection-II"><a href="#Redundant-Connection-II" class="headerlink" title="Redundant Connection II"></a>Redundant Connection II</h1><p><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">Redundant Connection II</a><br>这个题还是要冷静分析一下的，跟I不同，这个题是有向图，如果要构成tree，一个结点不能有两个父节点，这个树中不能有环。如果我们可以移除一条边，让这个tree valid的话，那么就只能存在一个入度为2的节点，我们把两个edge作为candidate存起来，然后用unionfind进行查找，如果出现了环，并且图中没有candidate，可以直接返回构成环的edge，否则返回第一个candidate，最后如果都是valid的话，就返回第二个candidate, 感慨牛逼啊。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] findRedundantDirectedConnection(int[][] edges) &#123;</span><br><span class="line">        int[] can1 = &#123;-1, -1&#125;;</span><br><span class="line">        int[] can2 = &#123;-1, -1&#125;;</span><br><span class="line">        int[] parent = new int[edges.length + 1];</span><br><span class="line">        for (int i = 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            if (parent[edges[i][1]] == 0) &#123;</span><br><span class="line">                parent[edges[i][1]] = edges[i][0];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                can2 = new int[] &#123;edges[i][0], edges[i][1]&#125;;</span><br><span class="line">                can1 = new int[] &#123;parent[edges[i][1]], edges[i][1]&#125;;</span><br><span class="line">                edges[i][1] = 0;//set invalid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125; // 初始化union find</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            if (edges[i][1] == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; // 遇见第二个让edge[1]成为入度为2的点</span><br><span class="line">            int child = edges[i][1];</span><br><span class="line">            int father = edges[i][0];</span><br><span class="line">            if (root(parent, father) == child) &#123; // 有环</span><br><span class="line">                if (can1[0] == -1) &#123; // 没有candidate</span><br><span class="line">                    return edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">                return can1;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[child] = father; // union </span><br><span class="line">        &#125;</span><br><span class="line">        return can2;</span><br><span class="line">    &#125;</span><br><span class="line">    int root(int[] parent, int i) &#123;</span><br><span class="line">        while (i != parent[i]) &#123;</span><br><span class="line">            parent[i] = parent[parent[i]];</span><br><span class="line">            i = parent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Couples-Holding-Hands"><a href="#Couples-Holding-Hands" class="headerlink" title="Couples Holding Hands"></a>Couples Holding Hands</h1><p><a href="https://leetcode.com/problems/couples-holding-hands/description/" target="_blank" rel="noopener">Couples Holding Hands</a><br>这个题也要使用unionfind，一旦出现不匹配的情况就进行union，这样就模拟了交换的次数，注意初始化unionfind的时候是初始化一半的数量的，这样相邻两个数的root才能是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">    public int[] father;</span><br><span class="line">    public int count;</span><br><span class="line">    public UnionFind(int n) &#123;</span><br><span class="line">        father = new int[n];</span><br><span class="line">        Arrays.fill(father, -1);</span><br><span class="line">        count = n;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int x) &#123;</span><br><span class="line">        if (father[x] &lt; 0) &#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        return father[x] = find(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int a, int b) &#123;</span><br><span class="line">        a = find(a);</span><br><span class="line">        b = find(b);</span><br><span class="line">        if (a != b) &#123;</span><br><span class="line">            if (father[a] &lt; father[b]) &#123;</span><br><span class="line">                father[a] += father[b];</span><br><span class="line">                father[b] = a;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                father[b] += father[a];</span><br><span class="line">                father[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int minSwapsCouples(int[] row) &#123;</span><br><span class="line">        int N = row.length / 2;</span><br><span class="line">        UnionFind uf = new UnionFind(N);</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            int a = row[2 * i];</span><br><span class="line">            int b = row[2 * i + 1];</span><br><span class="line">            uf.union(a / 2, b / 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return N - uf.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Is-Graph-Bipartite"><a href="#Is-Graph-Bipartite" class="headerlink" title="Is Graph Bipartite?"></a>Is Graph Bipartite?</h1><p><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">Is Graph Bipartite?</a><br>这个题是典型的bfs染色节点的问题，因为只有两个颜色，所以可以用类似滚动数组的方法，注意corner case 是每一个节点都要染色，不能一开始只加一个没染色的进去，这样可能会漏掉一大部分另外的图，图有可能是seperate的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBipartite(int[][] graph) &#123;</span><br><span class="line">        int n = graph.length;</span><br><span class="line">        int[] color = new int[n];</span><br><span class="line">        Arrays.fill(color, -1);</span><br><span class="line">        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (color[i] == -1) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                color[i] = 0;</span><br><span class="line">                while (!q.isEmpty()) &#123;</span><br><span class="line">                    int size = q.size();</span><br><span class="line">                    for (int k = 0; k &lt; size; k++) &#123;</span><br><span class="line">                        int temp = q.poll();</span><br><span class="line">                        int col = color[temp];</span><br><span class="line">                        for (int item : graph[temp]) &#123;</span><br><span class="line">                            if (color[item] == col) &#123;</span><br><span class="line">                                return false;</span><br><span class="line">                            &#125; else if (color[item] == -1) &#123;</span><br><span class="line">                                color[item] = 1 - col;</span><br><span class="line">                                q.add(item);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Find-Eventual-Safe-States"><a href="#Find-Eventual-Safe-States" class="headerlink" title="Find Eventual Safe States"></a>Find Eventual Safe States</h1><p><a href="https://leetcode.com/problems/find-eventual-safe-states/description/" target="_blank" rel="noopener">Find Eventual Safe States</a><br>dfs染色问题，我们要判断每个点是不是terminate的，就是它是否在一个环里，如果在环里就不是一个terminate节点，用染色方法来判断是否产生了环，访问过之后把它变为gray，如果dfs过程中再次出现gray的点，就是一个环的出现，如果没有，设为black，为terminate点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123;</span><br><span class="line">        int n = graph.length;</span><br><span class="line">        int[] color = new int[n];</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (dfs(i, graph, color)) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // gray : 1 black 2</span><br><span class="line">    public boolean dfs(int node, int[][] graph, int[] color) &#123;</span><br><span class="line">        if (color[node] &gt; 0) &#123; // if it is visited, determine whether it is a terminate node</span><br><span class="line">            return color[node] == 2;</span><br><span class="line">        &#125;</span><br><span class="line">        color[node] = 1; // set it as visited</span><br><span class="line">        for (int temp : graph[node]) &#123;</span><br><span class="line">            if (color[temp] == 2) &#123; // if the neighbor is terminate node. continue, our goal is find cycle</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (color[temp] == 1 || !dfs(temp, graph, color)) &#123; // if it is visited or visit it again</span><br><span class="line">                return false; // it is a cycle</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[node] = 2; // it is a terminate node</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Regions-Cut-By-Slashes"><a href="#Regions-Cut-By-Slashes" class="headerlink" title="Regions Cut By Slashes"></a>Regions Cut By Slashes</h1><p><a href="https://leetcode.com/problems/regions-cut-by-slashes/description/" target="_blank" rel="noopener">Regions Cut By Slashes</a><br>好题，这个题非常巧妙的运用了unionfind的方法，把每个单元格分为四个小块，然后根据出现的字符来union四个小块，这是单元格内的，之后就是合并单元格之间的，合并完之后再次调用find来计数就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">    int[] father;</span><br><span class="line">    public UnionFind(int n) &#123;</span><br><span class="line">        father = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int a) &#123;</span><br><span class="line">        if (father[a] == a) &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        return father[a] = find(father[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int a, int b) &#123;</span><br><span class="line">        a = find(a);</span><br><span class="line">        b = find(b);</span><br><span class="line">        if (a != b) &#123;</span><br><span class="line">            father[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int regionsBySlashes(String[] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        UnionFind uf = new UnionFind(4 * n * n);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                char c = grid[i].charAt(j);</span><br><span class="line">                int root = 4 * (i * n + j);</span><br><span class="line">                switch(c) &#123;</span><br><span class="line">                    case &apos;\\&apos;:</span><br><span class="line">                        uf.union(root + 0, root + 1);</span><br><span class="line">                        uf.union(root + 2, root + 3);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;/&apos;:</span><br><span class="line">                        uf.union(root + 0, root + 3);</span><br><span class="line">                        uf.union(root + 1, root + 2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos; &apos;:</span><br><span class="line">                        uf.union(root + 0, root + 1);</span><br><span class="line">                        uf.union(root + 1, root + 2);</span><br><span class="line">                        uf.union(root + 2, root + 3);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    uf.union(root + 2, root + 4 * n + 0);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    uf.union(root + 1, root + 4 + 3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4 * n * n; i++) &#123;</span><br><span class="line">            if (uf.find(i) == i) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Complexity</title>
      <link href="/2019/02/13/time-complexity/"/>
      <url>/2019/02/13/time-complexity/</url>
      
        <content type="html"><![CDATA[<h1 id="时间复杂度（Time-Complexity）"><a href="#时间复杂度（Time-Complexity）" class="headerlink" title="时间复杂度（Time Complexity）"></a>时间复杂度（Time Complexity）</h1><ul><li>O(logN)的算法几乎可以确定是二分法，如果一个算法的暴力解法的时间复杂度为O(N)，继续优化的结果一般只能是O(logn)， 一般不会考察O(1)的解法在面试的时候。</li></ul><ul><li><blockquote><p>一个算法的运行时间与其所要执行的语句的数量成正比，而所要执行的语句与问题规模正相关。因此算法的时间复杂度可以表示为一个与问题规模 N 相关的多项式。</p></blockquote></li><li>只保留最高次项作为时间复杂度的值，舍去系数、其他次项等。</li></ul><h1 id="常见的算法时间复杂度（背诵）"><a href="#常见的算法时间复杂度（背诵）" class="headerlink" title="常见的算法时间复杂度（背诵）"></a>常见的算法时间复杂度（背诵）</h1><div class="table-container"><table><thead><tr><th>复杂度</th><th style="text-align:right">对应的算法</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td>O(1)</td><td style="text-align:right">位运算</td><td style="text-align:center">这个复杂度一般不会考</td></tr><tr><td>O(logn)</td><td style="text-align:right">二分法，倍增法，快速幂算法，辗转相除法</td><td style="text-align:center"></td></tr><tr><td>O(n)</td><td style="text-align:right">枚举法，双指针算法，单调栈算法，KMP算法、Rabin Karp，Manacher’s Algorithm</td><td style="text-align:center"></td></tr><tr><td>O(nlogn)</td><td style="text-align:right">快速排序，归并排序，堆排序</td><td style="text-align:center"></td></tr><tr><td>O(n<sup>2</sup>)</td><td style="text-align:right">枚举法，动态规划，Dijkstra</td><td style="text-align:center"></td></tr><tr><td>O(n<sup>3</sup>)</td><td style="text-align:right">枚举法，动态规划，Floyd</td><td style="text-align:center"></td></tr><tr><td>O(2<sup>n</sup>)</td><td style="text-align:right">与组合有关的搜索问题</td><td style="text-align:center"></td></tr><tr><td>O(n!)</td><td style="text-align:right">与排列有关的搜索问题</td></tr></tbody></table></div><p>例如，给定一个已经排序的数组，现在有多次询问，每次询问一个数字是否在这个数组中，返回True or False.</p><ul><li>方法1： 每次扫描一遍数组，查看是否存在。 这个方法，每次查询的时间复杂度是: O(n)。</li></ul><ul><li>方法2：二分法：O(logn)。</li><li>方法3：存入Hashset：O(1)。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">   sum++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>倍增法 sum=log(n), 循环了log(n)次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">1</span>; j &lt;= n; j *= <span class="number">2</span>)&#123;</span><br><span class="line">      sum++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibo</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibo(n - <span class="number">1</span>) + Fibo(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">O(2<sup>/frac{n}{2}</sup>) ~ O(2<sup>n</sup>)</script><p>计算时间复杂度的上界：</p><script type="math/tex; mode=display">F(n) = F(n - 1) + F(n - 2) < 2 * F(n - 1)</script><p>时间复杂度的上界为：</p><script type="math/tex; mode=display">< T(n) = 2 * T(n - 1) + O(1) = O(2^n)</script><p>时间复杂度的下界为：</p><script type="math/tex; mode=display">> T(n) = 2 * T(n - 2) + O(1) = O(2 ^ /frac{n}{2})</script><p><a href="https://www.cnblogs.com/33debug/p/6848330.html" target="_blank" rel="noopener"><font color="red">Fibo算法分析</font></a><br><strong> 注意这个是结果每次都要求的 </strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] F = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">F[<span class="number">0</span>] = F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (F[n] != <span class="number">0</span>) <span class="keyword">return</span> F[n];</span><br><span class="line">    F[n] = Fibo(n<span class="number">-1</span>) + Fibo(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> F[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>O(n)<br><strong> 这个结果用F[n]记录，所以时间复杂度是不同的 </strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[i] &lt; window) &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)<br>典型的 双指针算法，[i, j)滑动窗口的两端，大家一定要记住，数循环次数是一个偷懒的时间复杂度计算方法，却不是最准确的时间复杂度计算方法。时间复杂度的定义，是程序总共执行的语句数目的数量级。在这个代码中，执行次数最多的是 j++ 这个循环主体。而这个循环体不会被执行O(n<sup>2</sup>)次，因为 j 在每次 i 循环的时候，不会被重置到 i 或者 0 的位置开始重新计算。j一直是自顾自的单向递增，那么一旦某一次 while 循环使得 j++ 执行了 n 次以后，while 循环就再也进不去了。因此总共的执行次数是O(n+n)=O(n)。</p><h1 id="T-函数推导法"><a href="#T-函数推导法" class="headerlink" title="T 函数推导法"></a>T 函数推导法</h1><p><strong> 二分法的T函数公式 </strong><br>$ T(n) = T(n/2) + O(1) $<br>T(n) : 求处理问题规模为n的数据时间复杂度是多少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = T(n/2) + O(1)</span><br><span class="line">     = T(n/4) + O(1) + O(1)</span><br><span class="line">     = T(n/8) + O(1) * 3</span><br><span class="line">     = T(n/16) + O(1) * 4</span><br><span class="line">     …</span><br><span class="line">     = T(1) + O(1) * logn</span><br><span class="line">     = O(logn)</span><br></pre></td></tr></table></figure></p><p>一些性质：</p><ol><li>T(1) = O(1)</li><li>k*O(n) = O(kn)</li><li>O(n) + O(m) = O(n+m)(同阶的不可以代替)</li></ol><h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><h3 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (n &gt; 1) &#123;</span><br><span class="line">   这里执行一个使用 O(n) 的算法，将 n 的规模缩小一半</span><br><span class="line">   n = n / 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>$ T(n) = T(n/2) + O(n) $<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = T(n/2) + O(n)</span><br><span class="line">     = T(n/4) + O(n/2) + O(n)</span><br><span class="line">     = T(n/8) + O(n/4) + O(n/2) + O(n)</span><br><span class="line">     = …</span><br><span class="line">     = T(1) + O(1) + O(2) + … O(n/2) + O(n)</span><br><span class="line">     = O(1 + 2 + 4 .. + n/2 + n)</span><br><span class="line">     = O(2n) = O(n)</span><br></pre></td></tr></table></figure></p></blockquote><p><strong> O(1 + 2 + 4 … + n/2 + n) = O(n)</strong> 带入1024计算然后加1可以得到结果为2047 = 2 * 1024 - 1  = O(2n) = O(n)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C &amp; C++ 1</title>
      <link href="/2019/02/11/interview1/"/>
      <url>/2019/02/11/interview1/</url>
      
        <content type="html"><![CDATA[<h1 id="指针变量引用"><a href="#指针变量引用" class="headerlink" title="指针变量引用"></a>指针变量引用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 10;</span><br><span class="line">int* p = &amp;a;</span><br><span class="line">int* &amp;pa = p;</span><br><span class="line">(*pa)++; //这里的pa是p的引用，对pa指向的内容+1，a = 2</span><br><span class="line">pa = &amp;b; //pa指向b的地址，由于pa是p的引用，所以p也指向b的地址 b = 11</span><br></pre></td></tr></table></figure><hr><h1 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* p </span><br><span class="line">*p = 5 // 因为p没有初始化，所以p是野指针，经常导致程序崩溃</span><br></pre></td></tr></table></figure><hr><h1 id="临时变量非法引用"><a href="#临时变量非法引用" class="headerlink" title="临时变量非法引用"></a>临时变量非法引用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const float pi = 3.14;</span><br><span class="line">float f;</span><br><span class="line">float f1(float r) &#123;</span><br><span class="line">    f = r * r * pi;</span><br><span class="line">    return f;    </span><br><span class="line">&#125;</span><br><span class="line">float&amp; f2(float r) &#123;</span><br><span class="line">    f = r * r * pi;</span><br><span class="line">    return f; // 返回f的引用    </span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    float f1(float r = 5);</span><br><span class="line">    float&amp; f2(float r = 5); //声明函数的默认参数调用，默认参数为5</span><br><span class="line">    float a = f1(); </span><br><span class="line">    float&amp; b = f1(); // 错误，f1里面计算的值会付给一个temp的临时变量，临时变量是无法建立引用的</span><br><span class="line">    float c = f2(); // 正确，返回全局变量f的引用</span><br><span class="line">    float&amp; d = f2(); // 正确，主函数不定义变量而是直接使用f的引用的方式，最节省内存空间的方式，注意有效期的问题 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">const int&amp; b = a;</span><br><span class="line">b = 1 // 错误，无法更改, 这样就可以向外暴露一个只读的接口值</span><br><span class="line">a = 1 //正确</span><br><span class="line"></span><br><span class="line">const int c = 5;</span><br><span class="line">int&amp; d = c //错误，必须是常量引用才可以，const int&amp; d = c</span><br></pre></td></tr></table></figure><p><strong>_常量必须用常量引用，非常量也可以用常量引用_</strong></p><hr><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><p>引用一般是用指针实现的，引用安全，一旦赋值不可能更改。</p>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ListNode</title>
      <link href="/2019/02/11/ListNode/"/>
      <url>/2019/02/11/ListNode/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这篇总结一下ListNode的题，这种题面试还是挺经常考的，易错高频，之前总结的不多，发现有些题还是非常巧妙的。</p><hr><h1 id="Add-Two-Numbers-II"><a href="#Add-Two-Numbers-II" class="headerlink" title="Add Two Numbers II"></a>Add Two Numbers II</h1><p><a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">Add Two Numbers II</a><br>这个题和Add Two Numbers的唯一不同就是，顺序的序列是反过来的，我觉得任何顺序反过来的题目感觉和逻辑相反的，都可以用stack来解决一下, 如果可以改变input，也可以用reverse linkedlist来变为add two numbers 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if (l1 == null) &#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l2 == null) &#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stk1 = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; stk2 = new Stack&lt;&gt;();</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        while (p1 != null) &#123;</span><br><span class="line">            stk1.push(p1);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (p2 != null) &#123;</span><br><span class="line">            stk2.push(p2);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        while (!stk1.isEmpty() || !stk2.isEmpty()) &#123;</span><br><span class="line">            int a = stk1.isEmpty() ? 0 : stk1.pop().val;</span><br><span class="line">            int b = stk2.isEmpty() ? 0 : stk2.pop().val;</span><br><span class="line">            int sum = a + b + carry;</span><br><span class="line">            carry = sum / 10;</span><br><span class="line">            int digit = sum % 10;</span><br><span class="line">            ListNode newNode = new ListNode(digit);</span><br><span class="line">            ListNode temp = dummy.next;</span><br><span class="line">            dummy.next = newNode;</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry == 1) &#123;</span><br><span class="line">            ListNode newNode = new ListNode(carry);</span><br><span class="line">            ListNode temp = dummy.next;</span><br><span class="line">            dummy.next = newNode;</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h1><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">Swap Nodes in Pairs</a><br>这个题和那个swap k nodes 很像，所以完全可以按一个招式解。题目的策略就是每找到一段符合要求的listnode串就进行reverselinkedlist的翻转，所以reverse linkedlist是重中之重，注意传入参数的时候要传入dummy节点和end的节点，这样就可以确定翻转串之后的结尾，返回值要返回start, 这样就可以更新dummy节点，继续向下递归即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = 2;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode last = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            int count = k - 1;</span><br><span class="line">            while (count != 0) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                if (cur == null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            // cur maybe null</span><br><span class="line">            last = reverseKNodes(last, cur);</span><br><span class="line">            cur = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode reverseKNodes(ListNode last, ListNode end) &#123;</span><br><span class="line">        ListNode start = last.next;</span><br><span class="line">        ListNode cur = start.next;</span><br><span class="line">        ListNode l = start;</span><br><span class="line">        if (end == null) &#123;</span><br><span class="line">            return start;</span><br><span class="line">        &#125;</span><br><span class="line">        // 1-&gt;2-&gt;3 3-&gt;2-&gt;1</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        // pay attention to the reverse</span><br><span class="line">        while (start.next != next) &#123;</span><br><span class="line">            l.next = cur.next;</span><br><span class="line">            cur.next = last.next;</span><br><span class="line">            last.next = cur;</span><br><span class="line">            ListNode n = l.next;</span><br><span class="line">            l = cur;</span><br><span class="line">            cur = n;</span><br><span class="line">        &#125;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a>Rotate List</h1><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">Rotate List</a><br>这个题就是找到要翻转节点的前一个节点然后把它后面的节点移到前面就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k % count == 0) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            k = k % count;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        while (k != -1) &#123; // pay attention to the this number</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast != null) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = dummy.next;</span><br><span class="line">        dummy.next = slow.next;</span><br><span class="line">        slow.next = null;</span><br><span class="line">        ListNode tail = dummy;</span><br><span class="line">        while (tail.next != null) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = temp;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a>Remove Duplicates from Sorted List II</h1><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="noopener">Remove Duplicates from Sorted List II</a><br>双指针去重，两层循环注意内层循环要判断是否为null，如果slow和fast之间相差大于1就说明他有重复的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        while (fast != null) &#123;</span><br><span class="line">            while (fast != null &amp;&amp; fast.val == slow.val) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (slow.next == fast) &#123;</span><br><span class="line">                cur.next = slow;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                cur.next = null;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = fast;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h1><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">Partition List</a><br>这个题inplace并不好做，还是老实的建立两个dummy节点，分别拼接不同的节点，最后合并起来就好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode partition(ListNode head, int x) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy1 = new ListNode(0);</span><br><span class="line">        ListNode dummy2 = new ListNode(0);</span><br><span class="line">        ListNode p1 = dummy1;</span><br><span class="line">        ListNode p2 = dummy2;</span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">            if (head.val &lt; x) &#123;</span><br><span class="line">                p1.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p1.next = null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p2.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">                p2.next = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = dummy2.next;</span><br><span class="line">        return dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h1><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="noopener">Copy List with Random Pointer</a><br>一般deep copy的主要做法是维护一个map存每个节点的副本，会耗费O(n)的空间，这个题先写一下map版本的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode head0 = head;</span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">            if (!memo.containsKey(head)) &#123;</span><br><span class="line">                memo.put(head, new RandomListNode(head.label));</span><br><span class="line">            &#125;</span><br><span class="line">            if (head.next != null) &#123;</span><br><span class="line">                if (!memo.containsKey(head.next)) &#123;</span><br><span class="line">                    memo.put(head.next, new RandomListNode(head.next.label));</span><br><span class="line">                &#125;</span><br><span class="line">                memo.get(head).next = memo.get(head.next);</span><br><span class="line">            &#125;</span><br><span class="line">            if (head.random != null) &#123;</span><br><span class="line">                if (!memo.containsKey(head.random)) &#123;</span><br><span class="line">                    memo.put(head.random, new RandomListNode(head.random.label));</span><br><span class="line">                &#125;</span><br><span class="line">                memo.get(head).random = memo.get(head.random);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return memo.get(head0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个题可以用O(1)的空间，首先在每个节点最后复制每个节点，A-&gt;B-&gt;C &gt; A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’<br>这样我们就可以维护一个前后的关系，即保护了next的关系，下一步我们要处理random的pointer<br>处理完了之后就把这条链broke up成两条链，返回新链就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode p = head;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            RandomListNode newNode = new RandomListNode(p.label);</span><br><span class="line">            newNode.next = p.next;</span><br><span class="line">            p.next = newNode;</span><br><span class="line">            p = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            p.next.random = (p.random == null) ? null : p.random.next;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        RandomListNode newHead = p.next;</span><br><span class="line">        RandomListNode p2 = newHead;</span><br><span class="line">        while (p2.next != null) &#123;</span><br><span class="line">            p.next = p2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">            p2.next = p2.next.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = p2.next;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h1><p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Linked List Cycle</a><br>快慢指针两种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (fast != slow);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a>Linked List Cycle II</h1><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">Linked List Cycle II</a><br>快慢指针，相遇之后一个一个指针重返开头，再次相遇即为cycle的起点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fast == null || fast.next == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        while (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h1><p><a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">Odd Even Linked List</a><br>最优的方法是维护一个oddtail和eventail每次拼接的时候各自拼各自的，最后进行一下合并就好，注意这个题不是node值进行划分的而是序号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode oddEvenList(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode oddTail = head;</span><br><span class="line">        ListNode evenTail = head.next;</span><br><span class="line">        ListNode evenHead = head.next;</span><br><span class="line">        while (evenTail != null &amp;&amp; evenTail.next != null) &#123;</span><br><span class="line">            oddTail.next = evenTail.next;</span><br><span class="line">            evenTail.next = evenTail.next.next;</span><br><span class="line">            oddTail = oddTail.next;</span><br><span class="line">            evenTail = evenTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        oddTail.next = evenHead;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a>Reorder List</h1><p><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="noopener">Reorder List</a><br>这个题就用快慢指针找到中点，然后翻转后面的链表，之后用双指针拼接一下就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p2 = reverse(slow);</span><br><span class="line">        slow.next = null;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        while (p2 != null) &#123;</span><br><span class="line">            ListNode temp = p1.next;</span><br><span class="line">            p1.next = p2;</span><br><span class="line">            ListNode next = p2.next;</span><br><span class="line">            p2.next = temp;</span><br><span class="line">            p1 = temp;</span><br><span class="line">            p2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode reverse(ListNode dummy) &#123;</span><br><span class="line">        ListNode start = dummy.next;</span><br><span class="line">        while (start.next != null) &#123;</span><br><span class="line">            ListNode cur = start.next;</span><br><span class="line">            start.next = cur.next;</span><br><span class="line">            cur.next = dummy.next;</span><br><span class="line">            dummy.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a>Insertion Sort List</h1><p><a href="https://leetcode.com/problems/insertion-sort-list/description/" target="_blank" rel="noopener">Insertion Sort List</a><br>这个题真的坑，如果一开始dummy连上head，那么就会造成第一个node的死循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode insertionSortList(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        //dummy.next = head; // this will cause first node link itself</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        // [4,2,1,3]</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            p = dummy;</span><br><span class="line">            while (p.next != null &amp;&amp; p.next.val &lt; cur.val) &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = p.next;</span><br><span class="line">            p.next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Shuffle-Linked-List"><a href="#Shuffle-Linked-List" class="headerlink" title="Shuffle Linked List"></a>Shuffle Linked List</h1><p>使用nlogn的时间来shuffle a linked list，这个就是linked list的归并排序，加上一个random，和sort linkedlist差不多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class LinkedList &#123;</span><br><span class="line">    int value;</span><br><span class="line">    LinkedList next;</span><br><span class="line">    public LinkedList(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ShuffleLinkedList &#123;</span><br><span class="line">    Random rand;</span><br><span class="line">    public ShuffleLinkedList &#123;</span><br><span class="line">        rand = new Random();</span><br><span class="line">    &#125;</span><br><span class="line">    public LinkedList Solution(LinkedList node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList slow = node;</span><br><span class="line">        LinkedList fast = node.next;</span><br><span class="line">        LinkedList last = slow;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            last = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125; </span><br><span class="line">        LinkedList dummy = new LinkedList(-1);</span><br><span class="line">        LinkedList cur = dummy;</span><br><span class="line">        last.next = null;</span><br><span class="line">        LinkedList leftHalf = Solution(node);</span><br><span class="line">        LinkedList rightHalf = Solution(slow);</span><br><span class="line">        // merge</span><br><span class="line">        while (leftHalf != null &amp;&amp; rightHalf != null) &#123;</span><br><span class="line">            if (rand.nextInt(2) == 0) &#123;</span><br><span class="line">                cur.next = leftHalf;</span><br><span class="line">                leftHalf = leftHalf.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur.next = rightHalf;</span><br><span class="line">                rightHalf = rightHalf.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            cur.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        while (leftHalf != null) &#123;</span><br><span class="line">            cur.next = leftHalf;</span><br><span class="line">        &#125;</span><br><span class="line">        while (rightHalf != null) &#123;</span><br><span class="line">            cur.next = rightHalf;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Intersection-of-Two-Linked-Lists"><a href="#Intersection-of-Two-Linked-Lists" class="headerlink" title="Intersection of Two Linked Lists"></a>Intersection of Two Linked Lists</h1><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">Intersection of Two Linked Lists</a><br>这个题还是很好的，首先找到第一个链表的结尾，然后连接另一个链表的表头，这样如果有intersection就可以形成一个环，然后调用linkedlistcycle2就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        if (headA == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; </span><br><span class="line">        if (headB == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = headA;</span><br><span class="line">        while (cur.next != null) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = headB;</span><br><span class="line">        ListNode res = linkedListCycle2(headA);</span><br><span class="line">        cur.next = null;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode linkedListCycle2(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fast == null || fast.next == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a>Palindrome Linked List</h1><p><a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">Palindrome Linked List</a><br>翻转list，然后进行比较，注意odd和even的区别, fast可以用来判断链表的奇偶。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 1 2</span><br><span class="line">    // 1 2 1</span><br><span class="line">    public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode last = null;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            last = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 可以根据fast来判断odd或者even链表</span><br><span class="line">        ListNode right = reverse(last.next);</span><br><span class="line">        last.next = null;</span><br><span class="line">        return isPalindrome(head, right);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode reverse(ListNode head) &#123;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        while (head.next != null) &#123;</span><br><span class="line">            ListNode cur = head.next;</span><br><span class="line">            head.next = cur.next;</span><br><span class="line">            cur.next = dummy.next;</span><br><span class="line">            dummy.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isPalindrome(ListNode p1, ListNode p2) &#123;</span><br><span class="line">        while (p1 != null &amp;&amp; p2 != null) &#123;</span><br><span class="line">            if (p1.val != p2.val) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p1 != null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // p2可能还剩一个，并不影响</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Plus-One-Linked-List"><a href="#Plus-One-Linked-List" class="headerlink" title="Plus One Linked List"></a>Plus One Linked List</h1><p><a href="https://leetcode.com/problems/plus-one-linked-list/description/" target="_blank" rel="noopener">Plus One Linked List</a><br>这个题可以用stack，也可以先找到右数第一个不是9的数 + 1，然后把右边的数变为0，如果没有就新建一个1节点，全部变为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode plusOne(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = null;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            if (cur.val != 9) &#123;</span><br><span class="line">                right = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right == null) &#123;</span><br><span class="line">            ListNode newHead = new ListNode(1);</span><br><span class="line">            newHead.next = head;</span><br><span class="line">            while (head != null) &#123;</span><br><span class="line">                head.val = 0;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return newHead;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.val = right.val + 1;</span><br><span class="line">            ListNode temp = right.next;</span><br><span class="line">            while (temp != null) &#123;</span><br><span class="line">                temp.val = 0;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Insert-into-a-Cyclic-Sorted-List"><a href="#Insert-into-a-Cyclic-Sorted-List" class="headerlink" title="Insert into a Cyclic Sorted List"></a>Insert into a Cyclic Sorted List</h1><p><a href="https://leetcode.com/problems/insert-into-a-cyclic-sorted-list/description/" target="_blank" rel="noopener">Insert into a Cyclic Sorted List</a><br>corner case 注意插入值相等的情况，而且注意插入最小值最大值的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node insert(Node head, int insertVal) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            Node node = new Node();</span><br><span class="line">            node.val = insertVal;</span><br><span class="line">            node.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        Node pre = head;</span><br><span class="line">        Node cur = pre.next;</span><br><span class="line">        while (cur != head) &#123; // find the position</span><br><span class="line">            if (pre.val &lt;= insertVal &amp;&amp; cur.val &gt;= insertVal) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pre.val &gt; cur.val &amp;&amp; (insertVal &lt;= cur.val || insertVal &gt;= pre.val)) &#123; // insert max min value</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = new Node();</span><br><span class="line">        node.val = insertVal;</span><br><span class="line">        node.next = cur;</span><br><span class="line">        pre.next = node;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Split-Linked-List-in-Parts"><a href="#Split-Linked-List-in-Parts" class="headerlink" title="Split Linked List in Parts"></a>Split Linked List in Parts</h1><p><a href="https://leetcode.com/problems/split-linked-list-in-parts/description/" target="_blank" rel="noopener">Split Linked List in Parts</a><br>这个题可以根据remain来进行平均分，这个方法有点类似于贪心，还是需要掌握的，注意corner case k &gt; n的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode[] splitListToParts(ListNode root, int k) &#123;</span><br><span class="line">        ListNode[] res = new ListNode[k];</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        int n = 0;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        int remain = n % k;</span><br><span class="line">        int perNum = n / k;</span><br><span class="line">        cur = root;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            res[count++] = cur;</span><br><span class="line">            ListNode pre = cur;</span><br><span class="line">            for (int j = 0; j &lt; perNum + ((remain &gt; 0) ? 1 : 0); j++) &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pre != null) &#123;</span><br><span class="line">                pre.next = null;</span><br><span class="line">            &#125;</span><br><span class="line">            remain--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Trie</title>
      <link href="/2019/02/04/trie/"/>
      <url>/2019/02/04/trie/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>大年初一，凌晨四点醒了等待新年睡不着，就总结一下，Trie 这个结构提供了前缀查找的可靠方法，要实现的代码也挺多的，还是要时常写一写的，这里就总结一下常见的Trie的题目。</p><h1 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a>Implement Trie (Prefix Tree)</h1><p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">Implement Trie (Prefix Tree)</a><br>这个题就是标准要实现一个Trie的结构，作为一个模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean hasWord;</span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">        this.children = new TrieNode[26];</span><br><span class="line">        this.hasWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    TrieNode root;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Inserts a word into the trie. */</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                cur.children[wc[i] - &apos;a&apos;] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.hasWord = true;</span><br><span class="line">        return;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the trie. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.hasWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if there is any word in the trie that starts with the given prefix. */</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        char[] wc = prefix.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * Trie obj = new Trie();</span><br><span class="line"> * obj.insert(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><hr><h1 id="Add-and-Search-Word-Data-structure-design"><a href="#Add-and-Search-Word-Data-structure-design" class="headerlink" title="Add and Search Word - Data structure design"></a>Add and Search Word - Data structure design</h1><p><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/description/" target="_blank" rel="noopener">Add and Search Word - Data structure design</a><br>这个题类似，不过要重写search函数，改为递归调用即可，注意加起始范围, 这个题还是多练练<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean hasWord;</span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">        this.children = new TrieNode[26];</span><br><span class="line">        this.hasWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Trie &#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        this.root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                cur.children[wc[i] - &apos;a&apos;] = new TrieNode();   </span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.hasWord = true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        return match(0, wc, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean match(int start, char[] wc,  TrieNode cur) &#123;</span><br><span class="line">        if (cur == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (wc[i] == &apos;.&apos;) &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">                    flag = flag || match(i + 1, wc, cur.children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                return flag;</span><br><span class="line">            &#125; else if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.hasWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class WordDictionary &#123;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    Trie root;</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        this.root = new Trie();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Adds a word into the data structure. */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        this.root.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        return root.search(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your WordDictionary object will be instantiated and called as such:</span><br><span class="line"> * WordDictionary obj = new WordDictionary();</span><br><span class="line"> * obj.addWord(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><hr><h1 id="Word-Search-II"><a href="#Word-Search-II" class="headerlink" title="Word Search II"></a>Word Search II</h1><p><a href="https://leetcode.com/problems/word-search-ii/description/" target="_blank" rel="noopener">Word Search II</a><br>先建Trie, 再DFS，DFS过程中要用startsWith降低复杂度，同时注意去重，可以搜索成功之后把hasWord变为false，也可以trienode加一个成员变量string 然后置空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean hasWord;</span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">        this.children = new TrieNode[26];</span><br><span class="line">        this.hasWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Trie &#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                cur.children[wc[i] - &apos;a&apos;] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.hasWord = true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean startsWith(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        boolean res = cur.hasWord;</span><br><span class="line">        cur.hasWord = false;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findWords(char[][] board, String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        Trie trie = new Trie();</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = board.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int m = board[0].length;</span><br><span class="line">        boolean[][] visited = new boolean[n][m];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                dfs(&quot;&quot;, trie, res, i, j, board, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(String word, Trie trie, List&lt;String&gt; res, int x, int y, char[][] board, boolean[][] visited) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length || visited[x][y]) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        word += board[x][y];</span><br><span class="line">        if (!trie.startsWith(word)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (trie.search(word)) &#123;</span><br><span class="line">            res.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = true;</span><br><span class="line">        dfs(word, trie, res, x + 1, y, board, visited);</span><br><span class="line">        dfs(word, trie, res, x - 1, y, board, visited);</span><br><span class="line">        dfs(word, trie, res, x, y + 1, board, visited);</span><br><span class="line">        dfs(word, trie, res, x, y - 1, board, visited);</span><br><span class="line">        visited[x][y] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stack</title>
      <link href="/2019/02/03/stack/"/>
      <url>/2019/02/03/stack/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>LeetCode里面有很多关于stack的题都是一些非常巧妙的方法，尤其是单调栈的应用，在这里总结一下关于stack的难题。<br>关于stack最先想到的就是<a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">20. Valid Parentheses</a>, 这个是stack的基本应用，简单的就不说了我们直接来难题。</p><hr><h1 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h1><p><a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">Trapping Rain Water</a><br>这道题可以用双指针的方法或者stack的方法，这里呢我们先用stack的方法。<br>先构造一个单调递减的stack，每次拿到一个数先比较栈顶元素是否小于这个数，如果小于这个数就pop出来进行计算，这个单调递增stack里面应该存坐标因为算积水量的时候要用到index的。pop出来一个元素之后就要马上计算以它左右为边界的地方能存多少水，height[i]与stack顶的元素找最小值，计算水量，重复循环直到stack为空或者stack顶的元素大于height[i];</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        if(height == null || height.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = height.length;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (stk.isEmpty()) &#123;</span><br><span class="line">                stk.push(i); // stk is empty we push element directly to stack</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (!stk.isEmpty() &amp;&amp; height[stk.peek()] &lt;= height[i]) &#123;</span><br><span class="line">                    int h = height[stk.pop()]; // get the height of current element to compute</span><br><span class="line">                    if (!stk.isEmpty()) &#123; // means it has leftbound</span><br><span class="line">                        int leftBound = height[stk.peek()];</span><br><span class="line">                        sum += (Math.min(leftBound, height[i]) - h) * (i - stk.peek() - 1); // compute water volumn</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(i); // push the index into stack</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Time Complexity and Space Complexity O(n)</span><br></pre></td></tr></table></figure><p><strong>注意stack一定是单调递减的, 不能有相等的, 存index挺关键的</strong></p><hr><h1 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a>Min Stack</h1><p><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">Min Stack</a><br>维持一个单调递减stack，stack栈顶一直维持所有的元素的最小值，每次加入的时候和栈顶元素进行判断，如果小于或等于栈顶元素或者stack为空的时候直接加入stack中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    Stack&lt;Integer&gt; stk1;</span><br><span class="line">    Stack&lt;Integer&gt; stk2;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        stk1 = new Stack&lt;&gt;();</span><br><span class="line">        stk2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stk1.push(x);</span><br><span class="line">        if (!stk2.isEmpty() &amp;&amp; stk2.peek() &lt; x) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        stk2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        int value = stk1.pop();</span><br><span class="line">        if (stk2.peek() == value) &#123;</span><br><span class="line">            stk2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stk1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        return stk2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack obj = new MinStack();</span><br><span class="line"> * obj.push(x);</span><br><span class="line"> * obj.pop();</span><br><span class="line"> * int param_3 = obj.top();</span><br><span class="line"> * int param_4 = obj.getMin();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><hr><h1 id="Max-Stack"><a href="#Max-Stack" class="headerlink" title="Max Stack"></a>Max Stack</h1><p><a href="https://leetcode.com/problems/max-stack/description/" target="_blank" rel="noopener">Max Stack</a><br>这里需要维持一个单调递增stack等于记录每加入一个数之后最大值是多少，popmax的时候要得到递增stack里面的当前最大值，pop原始stack的值，然后再一个个的push进去，注意的点是两个stack里面元素数目是相同的，这个是这个题的关键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class MaxStack &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    Stack&lt;Integer&gt; stk1;</span><br><span class="line">    Stack&lt;Integer&gt; stk2;</span><br><span class="line">    public MaxStack() &#123;</span><br><span class="line">        stk1 = new Stack&lt;&gt;();</span><br><span class="line">        stk2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stk1.push(x);</span><br><span class="line">        if (!stk2.isEmpty() &amp;&amp; stk2.peek() &gt; x) &#123;</span><br><span class="line">            stk2.push(stk2.peek());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stk2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        stk2.pop();</span><br><span class="line">        return stk1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stk1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int peekMax() &#123;</span><br><span class="line">        return stk2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int popMax() &#123;</span><br><span class="line">        int value = stk2.peek();</span><br><span class="line">        Stack&lt;Integer&gt; tmp = new Stack&lt;&gt;();</span><br><span class="line">        while (stk1.peek() != value) &#123;</span><br><span class="line">            tmp.add(stk1.pop());</span><br><span class="line">            stk2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk1.pop();</span><br><span class="line">        stk2.pop();</span><br><span class="line">        while (!tmp.isEmpty()) &#123;</span><br><span class="line">            push(tmp.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MaxStack object will be instantiated and called as such:</span><br><span class="line"> * MaxStack obj = new MaxStack();</span><br><span class="line"> * obj.push(x);</span><br><span class="line"> * int param_2 = obj.pop();</span><br><span class="line"> * int param_3 = obj.top();</span><br><span class="line"> * int param_4 = obj.peekMax();</span><br><span class="line"> * int param_5 = obj.popMax();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><hr><h1 id="Next-Greater-Element-I"><a href="#Next-Greater-Element-I" class="headerlink" title="Next Greater Element I"></a>Next Greater Element I</h1><p><a href="https://leetcode.com/problems/next-greater-element-i/description/" target="_blank" rel="noopener">Next Greater Element I</a><br>这个也是维持一个单调递减stack，每次加入一个比栈顶大的元素时要连续pop出来元素，这些比当前元素小的next greater element就是当前元素，用map记下来就好了，也很巧妙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        for (int num : nums2) &#123;</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; stk.peek() &lt; num) &#123;</span><br><span class="line">                memo.put(stk.pop(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums1.length;</span><br><span class="line">        int[] res = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = memo.getOrDefault(nums1[i], -1);</span><br><span class="line">        &#125; </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h1><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="noopener">Largest Rectangle in Histogram</a><br>这个题也非常的巧妙，维持一个单调递增stack，每出现的元素比栈顶元素小的时候，需要进行计算，以stack中元素为边长到当前元素之间的面积，如果计算过程中stack为空说明这个在最后一个元素前面的元素都比当前元素大，计算面积即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        if (heights == null || heights.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int n = heights.length;</span><br><span class="line">        // 维持一个单调递增stack这样的话，就可以每次pop出来的时候根据当前坐标计算面积</span><br><span class="line">        // 注意最后压入-1进行所有的清算</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = (i == n) ? -1 : heights[i];</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; cur &lt;= heights[stk.peek()]) &#123;</span><br><span class="line">                int h = heights[stk.pop()];</span><br><span class="line">                int w = stk.isEmpty() ? i : i - stk.peek() - 1;</span><br><span class="line">                max = Math.max(max, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h1><p><a href="https://leetcode.com/problems/maximal-rectangle/description/" target="_blank" rel="noopener">Maximal Rectangle</a><br>这个题和之前那个题不同之处就是扩展到了二维，每行都要算一下largest rectangle而已，也是非常巧妙的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        // 这个题需要降维来解，用84题的方法，每一行进行计算，累计一下进行直方图的计算</span><br><span class="line">        if (matrix == null || matrix.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix.length;</span><br><span class="line">        int m = matrix[0].length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[m];</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                dp[j] = (matrix[i][j] == &apos;0&apos;) ? 0 : dp[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, helper(dp));</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    public int helper(int[] dp) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int n = dp.length;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = (i == n) ? -1 : dp[i];</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; cur &lt;= dp[stk.peek()]) &#123;</span><br><span class="line">                int h = dp[stk.pop()];</span><br><span class="line">                int w = stk.isEmpty() ? i : i - stk.peek() - 1;</span><br><span class="line">                max = Math.max(max, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Binary-Tree-Postorder-Traversal"><a href="#Binary-Tree-Postorder-Traversal" class="headerlink" title="Binary Tree Postorder Traversal"></a>Binary Tree Postorder Traversal</h1><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a><br>一开始我自己的想法是记录一下访问的上一个值和stack里peek值进行比较判断子树是否遍历完，然后看了一个discussion一个大神的解答，只能大喊卧槽了, 利用linkedlist 和 stack，遍历过程中运用addfirst把加入的顺序反过来，背这个就完事了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while (!stk.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stk.pop();</span><br><span class="line">            ans.add(0, cur.val);</span><br><span class="line">            if (cur.left != null) &#123;</span><br><span class="line">                stk.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur.right != null) &#123;</span><br><span class="line">                stk.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Basic-Calculator"><a href="#Basic-Calculator" class="headerlink" title="Basic Calculator"></a>Basic Calculator</h1><p><a href="https://leetcode.com/problems/basic-calculator/description/" target="_blank" rel="noopener">Basic Calculator</a><br>这个题也是一个相当好stack的应用，维持一个num，res，sign是这个题的关键，都是integer类型的，stack负责处理碰到括号的情况，把原先的res和sign都压到stack里面清零这些值，计算括号里面的值，得到新的res值，再pop出来原来的值进行计算，每次遇到加减号计算，所以最后出循环也要计算一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int sign = 1;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char c = sc[i];</span><br><span class="line">            if (&apos;0&apos; &lt;= c &amp;&amp; c &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                num = num * 10 + c - &apos;0&apos;;</span><br><span class="line">            &#125; else if (c == &apos;+&apos;) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                sign = 1;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else if (c == &apos;-&apos;) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                sign = -1;  </span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else if (c == &apos;(&apos;) &#123;</span><br><span class="line">                stk.push(res);</span><br><span class="line">                stk.push(sign);</span><br><span class="line">                num = 0;</span><br><span class="line">                res = 0;</span><br><span class="line">                sign = 1;</span><br><span class="line">            &#125; else if (c == &apos;)&apos;) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                int tempSign = stk.pop();</span><br><span class="line">                int tempRes = stk.pop();</span><br><span class="line">                res = tempRes + tempSign * res;</span><br><span class="line">                num = 0;</span><br><span class="line">                sign = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += sign * num;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Verify-Preorder-Sequence-in-Binary-Search-Tree"><a href="#Verify-Preorder-Sequence-in-Binary-Search-Tree" class="headerlink" title="Verify Preorder Sequence in Binary Search Tree"></a>Verify Preorder Sequence in Binary Search Tree</h1><p><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/description/" target="_blank" rel="noopener">Verify Preorder Sequence in Binary Search Tree</a><br>这个题也是用stack的典型例子，维持一个单调递减stack还有一个low值，这个low值维持的是当前元素到末尾的lowerbound，每次出现元素比栈顶元素大的时候就说明进入到了右子树，栈顶元素就相应变成lowbound，继续pop来找到右子树的位置，如果过程中low值大于了当前值，返回false, O(1)space的方法有点巧妙，暂时就先不在这篇讲了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean verifyPreorder(int[] preorder) &#123;</span><br><span class="line">        if (preorder == null || preorder.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int low = Integer.MIN_VALUE;</span><br><span class="line">        for (int i : preorder) &#123;</span><br><span class="line">            if (low &gt;= i) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; i &gt;= stk.peek()) &#123;</span><br><span class="line">                low = stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Remove-Duplicate-Letters"><a href="#Remove-Duplicate-Letters" class="headerlink" title="Remove Duplicate Letters"></a>Remove Duplicate Letters</h1><p><a href="https://leetcode.com/problems/remove-duplicate-letters/description/" target="_blank" rel="noopener">Remove Duplicate Letters</a><br>这题也是用stack，先遍历字符串，记录哈希值，然后再次遍历一个一个加入stack中如果出现当前元素小于栈顶元素的情况那么就判断栈顶元素的memo值是否为0，不为0代表以后还会出现就先删掉，一直pop下去就行，维护一个visited，如果已经出现，就代表前方已经安排好了，挺巧妙的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicateLetters(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] memo = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            memo[s.charAt(i) - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] visited = new boolean[26];</span><br><span class="line">        Stack&lt;Character&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            memo[sc[i] - &apos;a&apos;]--;</span><br><span class="line">            if (visited[sc[i] - &apos;a&apos;]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; stk.peek() &gt; sc[i] &amp;&amp; memo[stk.peek() - &apos;a&apos;] &gt; 0) &#123;</span><br><span class="line">                visited[stk.peek() - &apos;a&apos;] = false;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(sc[i]);</span><br><span class="line">            visited[sc[i] - &apos;a&apos;] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!stk.isEmpty()) &#123;</span><br><span class="line">            sb.insert(0, stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a>Verify Preorder Serialization of a Binary Tree</h1><p><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/" target="_blank" rel="noopener">Verify Preorder Serialization of a Binary Tree</a><br>这个题利用stack不断删除叶节点，然后留到最后判断是不是只剩一个#了<br><img src="https://www.programcreek.com/wp-content/uploads/2016/04/verify-preorder-serialization-of-a-binary-tree-leetcode-java-730x468.jpg" alt="图示"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidSerialization(String preorder) &#123;</span><br><span class="line">        if (preorder == null || preorder.length() == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] strs = preorder.split(&quot;,&quot;);</span><br><span class="line">        int n = strs.length;</span><br><span class="line">        Stack&lt;String&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            String cur = strs[i];</span><br><span class="line">            while (cur.equals(&quot;#&quot;) &amp;&amp; !stk.isEmpty() &amp;&amp; stk.peek().equals(cur)) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                if (stk.isEmpty()) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.size() == 1 &amp;&amp; stk.peek().equals(&quot;#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph Theory - Single Source Shortest Distance Path</title>
      <link href="/2019/02/01/single-source-shortest-path/"/>
      <url>/2019/02/01/single-source-shortest-path/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>很气，昨天做OA竟然出了一个Bellman Ford的单源最短路径的问题，虽然学过，但是java代码当时不会写，所以应该OA也挂了，后来总结了一下发现的确是算法的基础还不够牢固，虽然上过算法课但是只是明白了其中的皮毛，真的要掌握还是要多花时间写博客进行总结，做题不用多要的是熟练，我感觉还是陷入了刷题数量的误区忘记了遍数多才是王道，停止虚荣的刷题把！！！单源最短路径虽然考的不多但是还是要掌握的</p><p>大致的意思是，给一个带权值的无向或者有向图和一个源点，计算从这个源点出发所得到的到达每个顶点的路径，并让到达每个顶点的权值最少。</p><hr><h1 id="Bell-Ford-Algorithm"><a href="#Bell-Ford-Algorithm" class="headerlink" title="Bell Ford Algorithm"></a>Bell Ford Algorithm</h1><p>这个算法可以作用在负权值的情况，而Dijkstra算法则不行。现实生活中还是有负权值的存在的，而且负权值可能会构成一个负权值的环这样的话，其他的算法可能会让这个环的权值一直变小，陷入死循环。</p><p>输入G(V,E)</p><ol><li>初始化一个和V数量相同大小的数组dist[]，初始化为INF, 源点为0</li><li>计算最短距离，需要循环V - 1次, 边的顺序是随意的但每次都要用相同的顺序<ul><li>如果dist[v] &gt; dist[u] + weight, 更新dist[v] = dist[u] + weight</li></ul></li><li>结束之后，再重新跑一边每条边，如果还是出现dist[v] &gt; dist[u] + weight, 说明有负权值环</li></ol><p><strong>算法复杂度O(VE)</strong></p><p>一般的OA或者OJ图的输入会给许多个二元数组，比如[1, 2], 昨天见的那道题有所不同是两个数组city_from[0]—1 city_to[0] —2<br>但是一般的建图算法都是一样的，一个map存节点和邻接节点，另一个map存入度, 注意是有向图还是无向图<br>图初始化代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void function(int[] arr1, int[] arr2, int[] weight) &#123;</span><br><span class="line">    // suppose there is not a duplicate edge and it is non directinal edge</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        map.putIfAbsent(arr1[i], new ArrayList&lt;&gt;());</span><br><span class="line">        map.putIfAbsent(arr2[i], new ArrayList&lt;&gt;());</span><br><span class="line">        map.get(arr1[i]).add(arr2[i]);</span><br><span class="line">        map.get(arr2[i]).add(arr1[i]);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到这个map之后就等于拿到了G(V, E), 然后我们就可以进行BellMan-Ford, 当然了这个题不建图操作起来更简单一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public static void bellmanFord(int source, int[] arrFrom, int[] arrTo, int[] weight, int number) &#123;</span><br><span class="line">        int[] dist = new int[number];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[source] = 0; </span><br><span class="line">        for (int i = 0; i &lt; number - 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; arrFrom.length; j++) &#123;</span><br><span class="line">                if (dist[arrFrom[j]] != Integer.MAX_VALUE &amp;&amp; dist[arrTo[j]] &gt; dist[arrFrom[j]] + weight[j]) &#123;</span><br><span class="line">                dist[arrTo[j]] = dist[arrFrom[j]] + weight[j];    </span><br><span class="line">                &#125; </span><br><span class="line">                if (dist[arrTo[j]] != Integer.MAX_VALUE &amp;&amp; dist[arrFrom[j]] &gt; dist[arrTo[j]] + weight[j]) &#123;</span><br><span class="line">                dist[arrFrom[j]] = dist[arrTo[j]] + weight[j];    </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查负环需要再跑一下上面的算法</span><br><span class="line">        for (int i = 0; i &lt; dist.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;index: %d, dist[i]: %d\n&quot;, i, dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arrFrom = &#123;0, 0, 1, 3, 1, 2&#125;;</span><br><span class="line">        int[] arrTo = &#123;1, 2, 3, 4, 4, 4&#125;;</span><br><span class="line">        int[] weight = &#123;1, 2, 2, 1, 1, 1&#125;;</span><br><span class="line">        bellmanFord(0, arrFrom, arrTo, weight, 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无向图其实就是有向图</strong><br>这么简单都没做出来，洗洗睡吧</p><p><img src="https://cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm.jpg" alt="example"><br><a href="https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/" target="_blank" rel="noopener">参考资料</a></p><hr><h1 id="Dijkstra-Algorithm"><a href="#Dijkstra-Algorithm" class="headerlink" title="Dijkstra Algorithm"></a>Dijkstra Algorithm</h1><p>这个算法举个leetcode的题为例子<br><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" target="_blank" rel="noopener">787. Cheapest Flights Within K Stops</a><br>题意是给你一个图每个edge有weights找到最多k stops的最便宜的方案。<br>就是要找到从起点出发的每个点的最短路径，在计算的过程中看符不符合要求。<br>如果需要构造新的class的话先构造新的class，把源点压入queue中，每次poll出来最小的，这个值就是最后确定的值，遍历它的所有邻接节点如果没有访问过就加入queue, 直到queue里不存在东西。<br>出现三元组的时候可以通过建立<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map</span><br></pre></td></tr></table></figure></p><p>来分别建立起点终点权值之间的关系.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    int num;</span><br><span class="line">    int weight;</span><br><span class="line">    public Point(int num, int weight) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">        this.weight = weight;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int[][] weights, int n, int src) &#123;</span><br><span class="line">    int[] dist = new int[n];    </span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">    //初始化</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        topo.put(i, new HashMap&lt;&gt;());    </span><br><span class="line">    &#125;</span><br><span class="line">    for (int[] weight : weights) &#123;</span><br><span class="line">        topo.get(weight[0]).put(weight[1], weight[2]);    </span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Point&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; (a.weight - b.weight));</span><br><span class="line">    q.add(new Point(src, 0));</span><br><span class="line">    while (!q.isEmpty()) &#123;</span><br><span class="line">        Point p = q.poll();</span><br><span class="line">        if (dist[p.num] == Integer.MAX_VALUE) &#123;</span><br><span class="line">            dist[p.num] = p.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : topo.get(p.num).entrySet&lt;&gt;()) &#123;</span><br><span class="line">            if (dist[entry.getKey()] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                q.add(new Point(entry.getKey(), entry.getValue() + p.weight));    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h1><p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" target="_blank" rel="noopener">787. Cheapest Flights Within K Stops</a><br><a href="https://leetcode.com/problems/network-delay-time/description/" target="_blank" rel="noopener">743. Network Delay Time</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/27/hello-world/"/>
      <url>/2018/04/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
