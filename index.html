<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="This is a personal learning blog">
<meta name="keywords" content="Algorithm, Computer">
<meta property="og:type" content="website">
<meta property="og:title" content="Shangzhen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Shangzhen&#39;s Blog">
<meta property="og:description" content="This is a personal learning blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shangzhen&#39;s Blog">
<meta name="twitter:description" content="This is a personal learning blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Shangzhen's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shangzhen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/dynamic-programing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/dynamic-programing/" itemprop="url">Dynamic Programming</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-26T09:11:34+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>动态规划是必须要掌握的算法，去年上过关于动态规划的专题班，但是没有更深一步的总结，这一轮刷题的时候还是要深入的总结一下动态规划的常见题型，常见的动态规划算法有两种，一种top down主要代表就是记忆化搜索，另一种是bottomup这种其实就是递推公式类型的，先把LeetCode上关于动态规划的常见题型总结一下。</p>
<h1 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h1><p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Longest Palindromic Substring</a><br>区间型动态规划,空间复杂度O(n^2), 也可以用字符串扩展的方法实现O(1)空间复杂度</p>
<p>dp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        int n = sc.length;</span><br><span class="line">        boolean[][] dp = new boolean[n][n];</span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = true;</span><br><span class="line">            for (int j = i; j &gt;= 0; j--) &#123;</span><br><span class="line">                if ((j + 2 &gt; i || dp[j + 1][i - 1]) &amp;&amp; sc[i] == sc[j]) &#123;</span><br><span class="line">                    dp[j][i] = true;</span><br><span class="line">                    if (i - j + 1 &gt; max) &#123;</span><br><span class="line">                        start = j;</span><br><span class="line">                        max = i - j + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字符串扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        int n = sc.length;</span><br><span class="line">        int start = -1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int len1 = expand(sc, i, i);</span><br><span class="line">            int len2 = expand(sc, i, i + 1);</span><br><span class="line">            if (len1 &gt; max) &#123;</span><br><span class="line">                start = i - len1 / 2;</span><br><span class="line">                max = len1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (len2 &gt; max) &#123;</span><br><span class="line">                start = i - (len2 - 1) / 2;</span><br><span class="line">                max = len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">    int expand(char[] sc, int i, int j) &#123;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; j &lt; sc.length) &#123;</span><br><span class="line">            if (sc[i] == sc[j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return j - i - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Longest-Palindromic-Subsequence"><a href="#Longest-Palindromic-Subsequence" class="headerlink" title="Longest Palindromic Subsequence"></a>Longest Palindromic Subsequence</h1><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">Longest Palindromic Subsequence</a><br>区间型动态规划, 这题求的是subsequence，代表这个区间内最长的子序列，可以不以i结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[][] dp = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = 1; // 初始化</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                dp[j][i] = Math.max(dp[j][i - 1], dp[j + 1][i]); // 先比较dp[j][i - 1], dp[j + 1][i]取最大值</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[j][i] = Math.max(dp[j + 1][i - 1] + 2, dp[j][i]); // 如果相同就加上。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h1><p><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="noopener">Regular Expression Matching</a><br>双序列型动态规划，这个题属于记忆化搜索，也是dp的一种，我们要做的事，建立一个visited数组和results数组记录结构，用两根指针来记录遍历位置，注意终止条件, 建议做十遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int m = p.length();</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        char[] pc = p.toCharArray();</span><br><span class="line">        boolean[][] visited = new boolean[n][m];</span><br><span class="line">        boolean[][] results = new boolean[n][m];</span><br><span class="line">        return helper(0, 0, sc, pc, visited, results);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean helper(int ps, int pp, char[] sc, char[] pc, boolean[][] visited, boolean[][] results) &#123;</span><br><span class="line">        if (pp == pc.length) &#123;</span><br><span class="line">            return ps == sc.length; // it has to be end</span><br><span class="line">        &#125;</span><br><span class="line">        if (ps == sc.length) &#123;</span><br><span class="line">            return isAllStar(pp, pc); // has to follow the pattern</span><br><span class="line">        &#125;</span><br><span class="line">        if (visited[ps][pp]) &#123;</span><br><span class="line">            return results[ps][pp];</span><br><span class="line">        &#125;</span><br><span class="line">        boolean match = false;</span><br><span class="line">        if (pp + 1 &lt; pc.length &amp;&amp; pc[pp + 1] == &apos;*&apos;) &#123; // regard a* as a part </span><br><span class="line">            match = helper(ps, pp + 2, sc, pc, visited, results) || ((sc[ps] == pc[pp] || pc[pp] == &apos;.&apos;) &amp;&amp; helper(ps + 1, pp, sc, pc, visited, results));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            match = (pc[pp] == sc[ps] || pc[pp] == &apos;.&apos;) &amp;&amp; helper(ps + 1, pp + 1, sc, pc, visited, results);</span><br><span class="line">        &#125;// it is the only way to make it right</span><br><span class="line">        visited[ps][pp] = true;</span><br><span class="line">        results[ps][pp] = match;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                     </span><br><span class="line">    boolean isAllStar(int pp, char[] pc) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = pp; i &lt; pc.length; i++) &#123;</span><br><span class="line">            if (count % 2 == 0) &#123;</span><br><span class="line">                if (pc[i] == &apos;*&apos;) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (pc[i] == &apos;*&apos;) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count % 2 == 0;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a>Wildcard Matching</h1><p><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="noopener">Wildcard Matching</a><br>这个题比上一个题要简单一点，但是大致思路是一样的，记忆化搜索，bugfree<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int m = p.length();</span><br><span class="line">        boolean[][] visited = new boolean[n][m];</span><br><span class="line">        boolean[][] results = new boolean[n][m];</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        char[] pc = p.toCharArray();</span><br><span class="line">        return helper(0, 0, sc, pc, visited, results);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean helper(int p1, int p2, char[] sc, char[] pc, boolean[][] visited, boolean[][] results) &#123;</span><br><span class="line">        if (p2 == pc.length) &#123;</span><br><span class="line">            return p1 == sc.length;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p1 == sc.length) &#123;</span><br><span class="line">            return isAllStar(p2, pc);</span><br><span class="line">        &#125;</span><br><span class="line">        if (visited[p1][p2]) &#123;</span><br><span class="line">            return results[p1][p2];</span><br><span class="line">        &#125;</span><br><span class="line">        boolean match = false;</span><br><span class="line">        if (pc[p2] == &apos;*&apos;) &#123;</span><br><span class="line">            match = helper(p1 + 1, p2, sc, pc, visited, results) || helper(p1, p2 + 1, sc, pc, visited, results);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            match = ((sc[p1] == pc[p2] || pc[p2] == &apos;?&apos;) &amp;&amp; helper(p1 + 1, p2 + 1, sc, pc, visited, results));</span><br><span class="line">        &#125;</span><br><span class="line">        visited[p1][p2] = true;</span><br><span class="line">        results[p1][p2] = match;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isAllStar(int p, char[] pc) &#123;</span><br><span class="line">        for (int i = p; i &lt; pc.length; i++) &#123;</span><br><span class="line">            if (pc[i] != &apos;*&apos;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Longest-Valid-Parentheses"><a href="#Longest-Valid-Parentheses" class="headerlink" title="Longest Valid Parentheses"></a>Longest Valid Parentheses</h1><p><a href="https://leetcode.com/problems/longest-valid-parentheses/description/" target="_blank" rel="noopener">Longest Valid Parentheses</a><br>序列型动态规划，注意递推条件，遍历，如果遇到 ( 或者 j = i - dp[i - 1] - 1 &lt; 0 或者 sc[j] == )都continue掉，代表以i-1结尾的字符不能构成valid parenthesis。其他的都是dp[i] = 2 + dp[i - 1] + dp[j];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestValidParentheses(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int j = i - dp[i - 1] - 2;</span><br><span class="line">            if (s.charAt(i - 1) == &apos;(&apos; || j &lt; 0 || s.charAt(j) == &apos;)&apos;) &#123;</span><br><span class="line">                dp[i] = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] = dp[i - 1] + dp[j] + 2;</span><br><span class="line">                res = Math.max(dp[i], res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h1><p><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">Edit Distance</a><br>这个题是双序列型动态规划, 三种情况分别算，初始条件搞清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] 表示word1前i个变为word2前j个所需的操作数。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int n = word1.length();</span><br><span class="line">        int m = word2.length();</span><br><span class="line">        int[][] dp = new int[n + 1][m + 1];</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= m; j++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    dp[i][j] = j;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (j == 0) &#123;</span><br><span class="line">                    dp[i][j] = i;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1]; // 不用改变</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1; // replace</span><br><span class="line">                &#125; </span><br><span class="line">                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j]); // add</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i][j]); // delete</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用滚动数组优化空间复杂度O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int n = word1.length();</span><br><span class="line">        int m = word2.length();</span><br><span class="line">        int[][] dp = new int[2][m + 1];</span><br><span class="line">        int old = 0;</span><br><span class="line">        int cur = 1; // rolling array</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            old = cur;</span><br><span class="line">            cur = 1 - cur;</span><br><span class="line">            for (int j = 0; j &lt;= m; j++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    dp[cur][j] = j;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (j == 0) &#123;</span><br><span class="line">                    dp[cur][j] = i;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[cur][j] = dp[old][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[cur][j] = dp[old][j - 1] + 1;</span><br><span class="line">                &#125; </span><br><span class="line">                dp[cur][j] = Math.min(dp[old][j] + 1, dp[cur][j]);</span><br><span class="line">                dp[cur][j] = Math.min(dp[cur][j - 1] + 1, dp[cur][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cur][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Scramble-String"><a href="#Scramble-String" class="headerlink" title="Scramble String"></a>Scramble String</h1><p><a href="https://leetcode.com/problems/scramble-string/description/" target="_blank" rel="noopener">Scramble String</a><br>记忆化搜索，分段递归， 但是这个方法效率很低，下次可以看一个比较快的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;String, Boolean&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">    public boolean isScramble(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s1.equals(s2)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(s1 + &quot;#&quot; + s2)) &#123;</span><br><span class="line">            return memo.get(s1 + &quot;#&quot; + s2);</span><br><span class="line">        &#125;</span><br><span class="line">        if (s1.length() == 1) &#123;</span><br><span class="line">            return s1.charAt(0) == s2.charAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s1.length();</span><br><span class="line">        // great</span><br><span class="line">        // eatgr</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123; // 不能 i &lt;= n 这样的话总是会判断s1 和 s2不能重复</span><br><span class="line">            if ((isScramble(s1.substring(0, i), s2.substring(0, i)) </span><br><span class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(i)))</span><br><span class="line">               || (isScramble(s1.substring(0, i), s2.substring(n - i)) </span><br><span class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(0, n - i)))) &#123;</span><br><span class="line">                memo.put(s1 + &quot;#&quot; + s2, true);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.put(s1 + &quot;#&quot; + s2, false);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a>Decode Ways</h1><p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Decode Ways</a><br>经典题，有很多corner case， 比如100 230等等，主要是以0相关的。如果遍历到这个数为0，需要向前看一位，如果这个位==1或者==2，就是合法的，否则continue;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numDecodings(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        if (s.charAt(0) == &apos;0&apos;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            if (s.charAt(i - 1) == &apos;0&apos;) &#123;</span><br><span class="line">                if (s.charAt(i - 2) == &apos;1&apos; || s.charAt(i - 2) == &apos;2&apos;) &#123;</span><br><span class="line">                    dp[i] = dp[i - 2];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (s.charAt(i - 2) == &apos;1&apos; || (s.charAt(i - 2) == &apos;2&apos; &amp;&amp; s.charAt(i - 1) &lt; &apos;7&apos;)) &#123;</span><br><span class="line">                dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h1><p><a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Unique Binary Search Trees</a><br>卡特兰树，<a href="http://www.cnblogs.com/grandyang/p/4299608.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Interleaving-String"><a href="#Interleaving-String" class="headerlink" title="Interleaving String"></a>Interleaving String</h1><p><a href="https://leetcode.com/problems/interleaving-string/description/" target="_blank" rel="noopener">Interleaving String</a><br>这个题类似像regular expression match可以采用记忆化搜索top-down的方法，每一个位置枚举可能出现的值，类似序列型动态规划，建议十遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isInterleave(String s1, String s2, String s3) &#123;</span><br><span class="line">        int memo[][] = new int[s1.length()][s2.length()];</span><br><span class="line">        for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; s2.length(); j++) &#123;</span><br><span class="line">                memo[i][j] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(s1, 0, s2, 0, s3, 0, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean helper(String s1, int i, String s2, int j, String s3, int k, int[][] memo) &#123;</span><br><span class="line">        if (i == s1.length()) &#123;</span><br><span class="line">            return s2.substring(j).equals(s3.substring(k));</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == s2.length()) &#123;</span><br><span class="line">            return s1.substring(i).equals(s3.substring(k));</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo[i][j] &gt;= 0) &#123;</span><br><span class="line">            return memo[i][j] == 1 ? true : false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean ans = false;</span><br><span class="line">        if ((s3.charAt(k) == s1.charAt(i) &amp;&amp; helper(s1, i + 1, s2, j, s3, k + 1, memo)) </span><br><span class="line">             || (s3.charAt(k) == s2.charAt(j) &amp;&amp; helper(s1, i, s2, j + 1, s3, k + 1, memo))) &#123;</span><br><span class="line">            ans = true;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j] = ans ? 1 : 0;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Distinct-Subsequences"><a href="#Distinct-Subsequences" class="headerlink" title="Distinct Subsequences"></a>Distinct Subsequences</h1><p><a href="https://leetcode.com/problems/distinct-subsequences/description/" target="_blank" rel="noopener">Distinct Subsequences</a><br>和上题类似，是区间型型动态规划，并不好想。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numDistinct(String s, String t) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int m = t.length();</span><br><span class="line">        int[][] memo = new int[n + 1][m + 1];</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            memo[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == t.charAt(j - 1)) &#123;</span><br><span class="line">                    memo[i][j] = memo[i - 1][j - 1] + memo[i - 1][j]; // 如果相等，就是有两种情况，i-1变成j，i-1变成j-1，加起来就行</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    memo[i][j] = memo[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return memo[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h1><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III</a><br>关键是五种状态需要搞清楚，还有限制条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int N = 2;</span><br><span class="line">        // 0 init</span><br><span class="line">        // 1 before</span><br><span class="line">        // 2 inFirstBuy</span><br><span class="line">        // 3 between buys</span><br><span class="line">        // 4 SecondBuy</span><br><span class="line">        // 5 Done</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[n + 1][2 * N + 2];</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; 2 * N + 2; j++) &#123;</span><br><span class="line">                if (j % 2 == 1) &#123;</span><br><span class="line">                    // 手里没有股票的时候，两种情况</span><br><span class="line">                    // 1. 前一天手里就没有股票</span><br><span class="line">                    // 2. 前一天有这一天卖了，需要算收益</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);</span><br><span class="line">                    if (i &gt; 1 &amp;&amp; j &gt; 1) &#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i - 1][j - 1] + prices[i - 1] - prices[i - 2], dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 手里有股票的时候，两种情况</span><br><span class="line">                    // 1. 前一天手里就有，需要算收益</span><br><span class="line">                    // 2. 今天刚买的，不需要算收益</span><br><span class="line">                    if (i &gt; 1) &#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i - 1][j] + prices[i - 1] - prices[i - 2], dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (j &gt; 1) &#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i - 1][j - 1], dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 枚举最大值</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int j = 1; j &lt;= 2 * N + 1; j += 2) &#123;</span><br><span class="line">            res = Math.max(res, dp[n][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Palindrome-Partitioning-II"><a href="#Palindrome-Partitioning-II" class="headerlink" title="Palindrome Partitioning II"></a>Palindrome Partitioning II</h1><p><a href="https://leetcode.com/problems/palindrome-partitioning-ii/description/" target="_blank" rel="noopener">Palindrome Partitioning II</a><br>字符串扩展方法判断palindrome, 然后序列型dp求解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCut(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[][] pattern = getPalin(s);</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[] dp = new int[n + 1]; // number of palindrome in the string</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = i; j &gt; 0; j--) &#123;</span><br><span class="line">                if (pattern[j - 1][i - 1] &amp;&amp; dp[j - 1] != Integer.MAX_VALUE) &#123; // it can be divided to palindrome </span><br><span class="line">                    dp[i] = Math.min(dp[j - 1] + 1, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n] - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean[][] getPalin(String s) &#123;</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        int n = sc.length;</span><br><span class="line">        boolean[][] res = new boolean[n][n];</span><br><span class="line">        for (int i = 0; i &lt; sc.length; i++) &#123;</span><br><span class="line">            int left = i;</span><br><span class="line">            int right = i;</span><br><span class="line">            while (left &gt;= 0 &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                if (sc[left] == sc[right]) &#123;</span><br><span class="line">                    res[left][right] = true;</span><br><span class="line">                    left--;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left = i;</span><br><span class="line">            right = i + 1;</span><br><span class="line">            while (left &gt;= 0 &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                if (sc[left] == sc[right]) &#123;</span><br><span class="line">                    res[left][right] = true;</span><br><span class="line">                    left--;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Burst-Balloons"><a href="#Burst-Balloons" class="headerlink" title="Burst Balloons"></a>Burst Balloons</h1><p><a href="https://leetcode.com/problems/burst-balloons/description/" target="_blank" rel="noopener">Burst Balloons</a><br>感觉这个题top-down + memoization更加好做一点，根据相应的范围进行recursion，还是挺巧妙的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] temp = new int[n + 2];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            temp[i + 1] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp[0] = temp[n + 1] = 1;</span><br><span class="line">        int[][] memo = new int[n + 2][n + 2];</span><br><span class="line">        return helper(memo, temp, 0, n + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(int[][] memo, int[] temp, int left, int right) &#123;</span><br><span class="line">        if (left + 1 == right) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo[left][right] != 0) &#123;</span><br><span class="line">            return memo[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = left + 1; i &lt; right; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, temp[i] * temp[left] * temp[right] + helper(memo, temp, left, i) + helper(memo, temp, i, right));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[left][right] = ans;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/24/database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/24/database/" itemprop="url">DataBase Interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-25T15:47:43+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase/" itemprop="url" rel="index">
                    <span itemprop="name">DataBase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<br>每个节点中有一系列的key，key之间有指针，指针所指向的所有key都大于等于指针的左key同时小于等于指针的右key。</p>
<h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>先在根节点二分查找，然后找到key所在指针，递归查找指针所指向的节点，到达leaf之后二分查找找到data。插入删除需要对tree分裂合并等维护平衡性</p>
<h2 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h2><p>这个面试的时候考过<br>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<ol>
<li><p>更少的查找次数<br>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。<br>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
</li>
<li><p>利用磁盘预读特性<br>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。<br>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
</li>
</ol>
<h1 id="MySQL-Index"><a href="#MySQL-Index" class="headerlink" title="MySQL Index"></a>MySQL Index</h1><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h2 id="B-index"><a href="#B-index" class="headerlink" title="B+ index"></a>B+ index</h2><p>默认，查找树速度快，排序分组，可以指定多个列为索引列共同组成键<br>innoDB的B+索引分为主索引和辅助索引，主索引的叶子节点data域记录着完整的数据，为聚簇索引，唯一性, 从而避免直接读取磁盘，因此对查询性能有很大的提升。<br>辅助索引的data域记录主键的值，使用辅助索引时需要先找到主键值，然后到主索引中查找。</p>
<h2 id="hash-index"><a href="#hash-index" class="headerlink" title="hash index"></a>hash index</h2><p>O(1)查找，无序，精确查找，无法支持部分查找和范围查找。<br>innoDB存储引擎有自适应哈希索引，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h2 id="Index-Advantages"><a href="#Index-Advantages" class="headerlink" title="Index Advantages"></a>Index Advantages</h2><ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>
<h2 id="Index-Conditions"><a href="#Index-Conditions" class="headerlink" title="Index Conditions"></a>Index Conditions</h2><ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/system-design-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/system-design-9/" itemprop="url">System Design 9 Message System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-19T13:24:44+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SystemDesign/" itemprop="url" rel="index">
                    <span itemprop="name">SystemDesign</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不经过服务器的话，无法处理离线消息<br>语音视频聊天一般来说是p2p，但是也有可能会因为审查需要进行一些采样然后存到服务器。</p>
<p>一般是点开一个thread才会去获取Message Table的，上线的时候只会读取UserThread table取读取last message， unread_count之类的。</p>
<p>poll = periodically pull</p>
<p>还是不太明白participant hash code有什么用，用户在app里发消息的时候app不会告诉server是在哪个thread id里发吗？ 因为即使是同一批participants也可以有多个thread<br>主要用途是：比如说A想给B发一个消息，那么首先需要知道A跟B之前有没有建立过thread，如果有的话就应该延用之前的thread id，这个时候就需要用A+B作为key去查询一下双方之前是否已经建立过thread。至于多人群聊，可以hash(participants+群聊名称)作为key。</p>
<p>index存在磁盘里，但是工作的时候会有一部分被load到内存里面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/system-design-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/system-design-8/" itemprop="url">System Design 8 Map Reduce</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-14T18:17:22+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SystemDesign/" itemprop="url" rel="index">
                    <span itemprop="name">SystemDesign</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>现在mapreduce是大数据工作的敲门砖，非常热门，面试的时候有可能也会考到具体的概念，系统设计更要准备一下。</p>
<hr>
<h1 id="Word-Count"><a href="#Word-Count" class="headerlink" title="Word Count"></a>Word Count</h1><p>普通wordcount = hashmap + for循环<br>优点：代码简单<br>缺点：一台机器，慢，内存大小受限</p>
<p>优化：多台机器for循环，拆分成多块，分别统计，然后合并。<br>缺点：一台机器合并的时候会有瓶颈bottle neck.</p>
<p>优化：采用并行合并(Map Reduce)</p>
<ol>
<li>机器划分(层次的依赖结构，时间上可能慢)</li>
<li>key划分(更好)<br>Map负责拆分，reduce负责合并。<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/whole%20steps.png?raw=true" alt="结构图"></li>
</ol>
<h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ol>
<li>input 输入文件</li>
<li>split 系统帮我们把文件平均分到各个机器上</li>
<li>Map 实现代码</li>
<li>传输整理，系统帮忙</li>
<li>Reduce实现代码</li>
<li>output 设定输出文件</li>
</ol>
<h2 id="Where-To-Aggregation"><a href="#Where-To-Aggregation" class="headerlink" title="Where To Aggregation"></a>Where To Aggregation</h2><p>聚集操作要reduce来做，如果在split中做，内存可能不够</p>
<h2 id="Transfer-And-Trim"><a href="#Transfer-And-Trim" class="headerlink" title="Transfer And Trim"></a>Transfer And Trim</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Word-Count-Structure.png?raw=true" alt="传输整理详细过程"></p>
<h2 id="How-Many-Mechines"><a href="#How-Many-Mechines" class="headerlink" title="How Many Mechines?"></a>How Many Mechines?</h2><p>It depends. 一般1000map，1000reduce</p>
<h2 id="Pros-And-Cons-For-Adding-Mechines"><a href="#Pros-And-Cons-For-Adding-Mechines" class="headerlink" title="Pros And Cons For Adding Mechines"></a>Pros And Cons For Adding Mechines</h2><p>Pros: 速度增加<br>Cons: 机器启动时间长<br>一般reduce操作的上限是key的数量</p>
<p><a href="https://www.lintcode.com/problem/word-count-map-reduce/description" target="_blank" rel="noopener">Word Count</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of OutputCollector:</span><br><span class="line"> * class OutputCollector&lt;K, V&gt; &#123;</span><br><span class="line"> *     public void collect(K key, V value);</span><br><span class="line"> *         // Adds a key/value pair to the output buffer</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class WordCount &#123;</span><br><span class="line"></span><br><span class="line">    public static class Map &#123;</span><br><span class="line">        public void map(String key, String value, OutputCollector&lt;String, Integer&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, int value);</span><br><span class="line">            StringTokenizer tok = new StringTokenizer(value);</span><br><span class="line">            while (tok.hasMoreTokens())&#123;</span><br><span class="line">                String word = tok.nextToken();</span><br><span class="line">                output.collect(word, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Reduce &#123;</span><br><span class="line">        public void reduce(String key, Iterator&lt;Integer&gt; values,</span><br><span class="line">                           OutputCollector&lt;String, Integer&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, int value);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            while(values.hasNext())&#123;</span><br><span class="line">                sum += values.next();</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key,sum);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Build-Inverted-Index"><a href="#Build-Inverted-Index" class="headerlink" title="Build Inverted Index"></a>Build Inverted Index</h1><p>举例：<br>0: deer, build<br>1: deer, apple<br>转化为：<br>deer: 0, 1<br>build: 0<br>apple: 1<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Inverted%20Index.png?raw=true" alt="结构"><br><a href="https://www.lintcode.com/problem/inverted-index-map-reduce/description" target="_blank" rel="noopener">Inverted Index</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of OutputCollector:</span><br><span class="line"> * class OutputCollector&lt;K, V&gt; &#123;</span><br><span class="line"> *     public void collect(K key, V value);</span><br><span class="line"> *         // Adds a key/value pair to the output buffer</span><br><span class="line"> * &#125;</span><br><span class="line"> * Definition of Document:</span><br><span class="line"> * class Document &#123;</span><br><span class="line"> *     public int id;</span><br><span class="line"> *     public String content;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class InvertedIndex &#123;</span><br><span class="line"></span><br><span class="line">    public static class Map &#123;</span><br><span class="line">        public void map(String _, Document value,</span><br><span class="line">                        OutputCollector&lt;String, Integer&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, int value);</span><br><span class="line">            StringTokenizer tokenizer = new StringTokenizer(value.content);</span><br><span class="line">            while (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String word = tokenizer.nextToken();</span><br><span class="line">                output.collect(word, value.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Reduce &#123;</span><br><span class="line">        public void reduce(String key, Iterator&lt;Integer&gt; values,</span><br><span class="line">                           OutputCollector&lt;String, List&lt;Integer&gt;&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, List&lt;Integer&gt; value);</span><br><span class="line">            List&lt;Integer&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">            int left = -1;</span><br><span class="line">            while (values.hasNext()) &#123;</span><br><span class="line">                int now = values.next();</span><br><span class="line">                if (left != now) &#123;</span><br><span class="line">                    results.add(now);</span><br><span class="line">                &#125;</span><br><span class="line">                left = now;</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Anagram"><a href="#Anagram" class="headerlink" title="Anagram"></a>Anagram</h1><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Anagram.png?raw=true" alt="结构"><br><a href="https://www.lintcode.com/problem/anagram-map-reduce/description" target="_blank" rel="noopener">Anagram</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of OutputCollector:</span><br><span class="line"> * class OutputCollector&lt;K, V&gt; &#123;</span><br><span class="line"> *     public void collect(K key, V value);</span><br><span class="line"> *         // Adds a key/value pair to the output buffer</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Anagram &#123;</span><br><span class="line"></span><br><span class="line">    public static class Map &#123;</span><br><span class="line">        public void map(String key, String value,</span><br><span class="line">                        OutputCollector&lt;String, String&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, String value);</span><br><span class="line">            StringTokenizer tokenizer = new StringTokenizer(value);</span><br><span class="line">            while (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String word = tokenizer.nextToken();</span><br><span class="line">                char[] sc = word.toCharArray();</span><br><span class="line">                Arrays.sort(sc);</span><br><span class="line">                output.collect(new String(sc), word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Reduce &#123;</span><br><span class="line">        public void reduce(String key, Iterator&lt;String&gt; values,</span><br><span class="line">                           OutputCollector&lt;String, List&lt;String&gt;&gt; output) &#123;</span><br><span class="line">            // Write your code here</span><br><span class="line">            // Output the results into output buffer.</span><br><span class="line">            // Ps. output.collect(String key, List&lt;String&gt; value);</span><br><span class="line">            List&lt;String&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">            while (values.hasNext()) &#123;</span><br><span class="line">                results.add(values.next());</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Design-Map-Reduce-System"><a href="#Design-Map-Reduce-System" class="headerlink" title="Design Map Reduce System"></a>Design Map Reduce System</h1><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Map%20Reduce%20Design.png?raw=true" alt="结构"> </p>
<h2 id="Steps-1"><a href="#Steps-1" class="headerlink" title="Steps"></a>Steps</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/whole%20process.png?raw=true" alt="Steps"></p>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q/A"></a>Q/A</h2><ol>
<li>Mapper 和 Reducer的工作顺序<br> 先Mapper, 再Reducer</li>
<li>Mapper, Reducer挂了怎么办<br> 重新分配机器</li>
<li>Reducer中key很多怎么办<br> 加一个random后缀，类似shared key</li>
<li>Input和Output放在哪<br> GFS</li>
<li>Local Disk上面的mapper output data 有没有必要保存在GFS上<br> 没有，丢了重做就好</li>
<li>Mapper 和 Reducer可以在一台机器吗<br> 设计不大好，两种操作都需要预处理，所以两个机器比较好</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/computer-system-elf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/computer-system-elf/" itemprop="url">Computer System 1 - Elf Info Reader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-14T17:14:58+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ComputerSystem/" itemprop="url" rel="index">
                    <span itemprop="name">ComputerSystem</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><h2 id="stat"><a href="#stat" class="headerlink" title="stat()"></a>stat()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;    </span><br><span class="line">#include &lt;sys/stat.h&gt;   </span><br><span class="line">int stat(</span><br><span class="line">　　const char *filename    //文件或者文件夹的路径</span><br><span class="line">　　, struct stat *buf      //获取的信息保存在内存中</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>把文件信息存到stat的结构体指针中, 成功return 0, 失败return -1</p>
<hr>
<h2 id="struct-stat"><a href="#struct-stat" class="headerlink" title="struct stat"></a>struct stat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct stat  </span><br><span class="line">&#123;   </span><br><span class="line">    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/  </span><br><span class="line">    ino_t       st_ino;     /* inode number -inode节点号*/    </span><br><span class="line">    mode_t      st_mode;    /* protection -保护模式?*/    </span><br><span class="line">    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/    </span><br><span class="line">    uid_t       st_uid;     /* user ID of owner -user id*/    </span><br><span class="line">    gid_t       st_gid;     /* group ID of owner - group id*/    </span><br><span class="line">    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/    </span><br><span class="line">    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/    </span><br><span class="line">    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/    </span><br><span class="line">    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/    </span><br><span class="line">    time_t      st_atime;   /* time of last access -最近存取时间*/    </span><br><span class="line">    time_t      st_mtime;   /* time of last modification -最近修改时间*/    </span><br><span class="line">    time_t      st_ctime;   /* time of last status change - */    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>常用的是 st_size 文件的大小, 修改时间等</p>
<hr>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><p><strong>将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值, 块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作, 其返回值为指向S的指针</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">void *memset(void *s,int ch, unsigned n);</span><br><span class="line"></span><br><span class="line">memset(&amp;elfData, 0, sizeof(elfData));</span><br><span class="line">// elfData 里面的指针也可以直接赋值成null</span><br></pre></td></tr></table></figure></p>
<p>用来清空或重置或初始化</p>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *path, int access, int mode)；</span><br></pre></td></tr></table></figure>
<ul>
<li>返回文件句柄, return -1 返回失败 由于第三个参数mode只有当access为O_CREAT的时候才有效，因此open的函数实现是一个可变参数函数</li>
<li>每个文件都属于自己的句柄，例如标准输入是0，标准输出是1，标准出错是2。</li>
<li>每打开一个文件就会返回句柄来操作这个文件，一般是从3开始，然后4,5,6一直下去。</li>
<li>close（fd）之后句柄就返回给系统，例如打开一个文件后fd是3，close之后再打开另外一个文件也还是3，但代表的文件不一样了</li>
<li>access O_RDONLY  1 只读;    O_WRONLY 2  只写;   O_RDWR  4  读写 </li>
</ul>
<hr>
<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h1><p>这个函数是这个作业的重点，要充分理解这个函数的作用, 有点妈卖批的感觉<br><a href="http://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">man page mmap()</a><br>在这里总结一下</p>
<ol>
<li>linux 的系统调用函数，为了让client和server之间的数据交流更快一点实现了内存映射的功能</li>
<li>一般来讲client和server之间要通过IPC(管道、消息队列)进行访问，数据需要拷贝四次(I/O操作)，输入文件-&gt;server-&gt;IPC-&gt;client-&gt;输出文件, mmap通过映射到内存，实现输入输出文件通过内存沟通, 代替了I/O操作，频繁读写有优势</li>
<li>将特殊文件进行匿名内存映射，为关联进程提供共享内存空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">       // addr 指定地址，通常设为NULL 或 0, 自动选址</span><br><span class="line">       // length 代表将文件的多大内存存到内存里</span><br><span class="line">       // prot 映射区域的保护方式。可以为以下几种方式的组合：</span><br><span class="line">            PROT_EXEC 映射区域可被执行</span><br><span class="line">            PROT_READ 映射区域可被读取</span><br><span class="line">            PROT_WRITE 映射区域可被写入</span><br><span class="line">            PROT_NONE 映射区域不能存取</span><br><span class="line">       // flags 影响映射区域的各种特性</span><br><span class="line">           MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享</span><br><span class="line">           MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，此区域作的任何修改都不会写回原来的文件内容</span><br><span class="line">       // fd 要映射文件的文件描述符, 文件句柄</span><br><span class="line">       // offset 偏移量，从文件哪个部分开始映射一般设为1</span><br><span class="line">       int munmap(void *addr, size_t length);</span><br><span class="line"></span><br><span class="line">       data = mmap(0, fileStats.st_size, PROT_READ, MAP_SHARED, fileNum, 0);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define handle_error(msg) \</span><br><span class="line">    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    char *addr;</span><br><span class="line">    int fd;</span><br><span class="line">    struct stat sb;</span><br><span class="line">    off_t offset, pa_offset;</span><br><span class="line">    size_t length;</span><br><span class="line">    ssize_t s;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 3 || argc &gt; 4) &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s file offset [length]\n&quot;, argv[0]);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[1], O_RDONLY);</span><br><span class="line">    if (fd == -1)</span><br><span class="line">        handle_error(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">    if (fstat(fd, &amp;sb) == -1)           /* To obtain file size */</span><br><span class="line">        handle_error(&quot;fstat&quot;);</span><br><span class="line"></span><br><span class="line">    offset = atoi(argv[2]);</span><br><span class="line">    pa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - 1);</span><br><span class="line">        /* offset for mmap() must be page aligned */</span><br><span class="line"></span><br><span class="line">    if (offset &gt;= sb.st_size) &#123;</span><br><span class="line">        fprintf(stderr, &quot;offset is past end of file\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (argc == 4) &#123;</span><br><span class="line">        length = atoi(argv[3]);</span><br><span class="line">        if (offset + length &gt; sb.st_size)</span><br><span class="line">            length = sb.st_size - offset;</span><br><span class="line">                /* Can&apos;t display bytes past end of file */</span><br><span class="line">    &#125; else &#123;    /* No length arg ==&gt; display to end of file */</span><br><span class="line">        length = sb.st_size - offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,</span><br><span class="line">                MAP_PRIVATE, fd, pa_offset);</span><br><span class="line">    if (addr == MAP_FAILED)</span><br><span class="line">        handle_error(&quot;mmap&quot;);</span><br><span class="line"></span><br><span class="line">    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);</span><br><span class="line">    if (s != length) &#123;</span><br><span class="line">        if (s == -1)</span><br><span class="line">            handle_error(&quot;write&quot;);</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, &quot;partial write&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(addr, length + offset - pa_offset);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="ELF-Data-Structure"><a href="#ELF-Data-Structure" class="headerlink" title="ELF Data Structure"></a>ELF Data Structure</h1><p><a href="http://man7.org/linux/man-pages/man5/elf.5.html" target="_blank" rel="noopener">man page for elf data</a><br>可执行文件的结构顺序如下：<br>ELF Header-&gt;Program Header table or Section Header Table or both<br>ELF在起始位置, ELFheader里面有program header 和 section header table的offset</p>
<h2 id="ELF-Header-Ehdr"><a href="#ELF-Header-Ehdr" class="headerlink" title="ELF Header(Ehdr)"></a>ELF Header(Ehdr)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    unsigned char e_ident[EI_NIDENT];</span><br><span class="line">    uint16_t      e_type;</span><br><span class="line">    uint16_t      e_machine;</span><br><span class="line">    uint32_t      e_version;</span><br><span class="line">    ElfN_Addr     e_entry;</span><br><span class="line">    ElfN_Off      e_phoff;</span><br><span class="line">    ElfN_Off      e_shoff;</span><br><span class="line">    uint32_t      e_flags;</span><br><span class="line">    uint16_t      e_ehsize;</span><br><span class="line">    uint16_t      e_phentsize;</span><br><span class="line">    uint16_t      e_phnum;</span><br><span class="line">    uint16_t      e_shentsize;</span><br><span class="line">    uint16_t      e_shnum;</span><br><span class="line">    uint16_t      e_shstrndx;</span><br><span class="line">&#125; ElfN_Ehdr;</span><br></pre></td></tr></table></figure>
<p>char == 1 byte == 16 bit </p>
<ul>
<li>e_ident: 包含怎么解析这个的信息，数组里面前四个必须是ELFMAG0、ELFMAG1、ELFMAG2、ELFMAG3，可以通过这个判断这个是不是一个ELF文件</li>
</ul>
<p>作业中header可以直接使用这个完成copy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(&amp;elfData, data, sizeof(Elf64_Ehdr));</span><br></pre></td></tr></table></figure></p>
<p>剩下的就是如何完成其他两个table的copy</p>
<ul>
<li>e_phentsize: This member holds the size in bytes of one entry in the file’s program header table; all entries are the same size.</li>
<li>e_phnum: This member holds the number of entries in the program header table.</li>
<li>e_shentsize: This member holds a sections header’s size in bytes.  A section header is one entry in the section header table;all entries are the same size.</li>
<li>e_shnum: This member holds the number of entries in the section header table.</li>
<li>e_phoff: This member holds the program header table’s file offset in bytes.</li>
<li>e_shoff: This member holds the section header table’s file offset in bytes.</li>
<li>e_shstrndx: This member holds the section header table index of the entry associated with the section name string table.If the file has no section name string table, this member holds the value SHN_UNDEF.  If the index of section name string table section is larger than or equal to SHN_LORESERVE (0xff00), this member holds SHN_XINDEX (0xffff) and the real index of the section name string table section is held in the sh_link member of the initial entry in section header table.  Otherwise, the sh_link member of the initial entry in section header table contains the value zero.</li>
</ul>
<hr>
<h2 id="Program-Header-Phdr"><a href="#Program-Header-Phdr" class="headerlink" title="Program Header(Phdr)"></a>Program Header(Phdr)</h2><p>An executable or shared object file’s program header table is an array of structures, each describing a segment or other information the system needs to prepare the program for execution.<br>告诉系统如何准备执行这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t   p_type;</span><br><span class="line">    uint32_t   p_flags;</span><br><span class="line">    Elf64_Off  p_offset;</span><br><span class="line">    Elf64_Addr p_vaddr;</span><br><span class="line">    Elf64_Addr p_paddr;</span><br><span class="line">    uint64_t   p_filesz;</span><br><span class="line">    uint64_t   p_memsz;</span><br><span class="line">    uint64_t   p_align;</span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void *calloc(size_t n, size_t size);</span><br><span class="line">elfData-&gt;programHeader = (Elf64_Phdr*)calloc(elfData-&gt;elfHeader.e_phnum, sizeof(Elf64_Phdr));</span><br><span class="line">有个疑问？sizeof(Elf64_Phdr) == e_phentsize ????</span><br><span class="line">类似malloc(), 不同是calloc已经初始化好了, 适合初始化数组</span><br><span class="line">通过e_phoff 找到起始位置, for循环memcpy</span><br><span class="line">char* pointer_offset = data + ret-&gt;elfHeader.e_phoff;</span><br><span class="line">for (int i = 0; i &lt; ret-&gt;elfHeader.e_phnum; i++) &#123;</span><br><span class="line">    memcpy(&amp;ret-&gt;programHeader[i], pointer_offset, sizeof(Elf64_Phdr));</span><br><span class="line">    pointer_offset += sizeof(Elf64_Phdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Section-Header-Shdr"><a href="#Section-Header-Shdr" class="headerlink" title="Section Header (Shdr)"></a>Section Header (Shdr)</h2><p>A file’s section header table lets one locate all the file’s sections<br>找到文件所有section</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t   sh_name;</span><br><span class="line">    uint32_t   sh_type;</span><br><span class="line">    uint64_t   sh_flags;</span><br><span class="line">    Elf64_Addr sh_addr;</span><br><span class="line">    Elf64_Off  sh_offset;</span><br><span class="line">    uint64_t   sh_size;</span><br><span class="line">    uint32_t   sh_link;</span><br><span class="line">    uint32_t   sh_info;</span><br><span class="line">    uint64_t   sh_addralign;</span><br><span class="line">    uint64_t   sh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<h3 id="Section-Name"><a href="#Section-Name" class="headerlink" title="Section Name"></a>Section Name</h3><p>老师给的数据结构需要存名字，所以在calloc的时候要多分一点内存，宏定义一个NAMEBUFFER = 100</p>
<ul>
<li>SHN_LORESERVE: This value specifies the lower bound of the range of reserved indices.</li>
<li>sh_link: This member holds a section header table index link, whose interpretation depends on the section type.</li>
<li>sh_name: This member specifies the name of the section.  Its value is an index into the section header string table section, giving the location of a null-terminated string.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int shNameStringIndex; // 找到namestring的index</span><br><span class="line">if (ret-&gt;elfHeader.e_shstrndx &gt;= SHN_LORESERVE) &#123; // 存的地方是不同的</span><br><span class="line">    shNameStringIndex = ret-&gt;sections[0].sectionHeader.sh_link; // 拿到section0 的link, 存在这里</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    shNameStringIndex = ret-&gt;elfHeader.e_shstrndx; // 存在这里 </span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; ret-&gt;elfHeader.e_shnum; i++) &#123;</span><br><span class="line">    memcpy(&amp;ret-&gt;sections[i].sectionHeader, pointer_offset, sizeof(Elf64_Shdr));    </span><br><span class="line">    pointer_offset += ret-&gt;elfHeader.e_shentsize;</span><br><span class="line">&#125;</span><br><span class="line">for (int j = 0; j &lt; ret-&gt;elfHeader.e_shnum; j++) &#123;</span><br><span class="line">    ret-&gt;sections[j].sectionName = strdup(data + ret-&gt;sections[shNameStringIndex].sectionHeader.sh_offset</span><br><span class="line">        + ret-&gt;sections[j].sectionHeader.sh_name); // strdup复制字符串(里面其实是地址)</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Elf Section build done&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="Symbol-List"><a href="#Symbol-List" class="headerlink" title="Symbol List"></a>Symbol List</h3><p>通过与sectionname的对比找到相应的section index，通过sectionheader的size和Elf64_Sym找到symbol list的size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (symTableIndex &gt; 0) &#123;</span><br><span class="line">   ret-&gt;otherSymbols.size = ret-&gt;sections[symTableIndex].sectionHeader.sh_size / sizeof(Elf64_Sym);</span><br><span class="line">   ret-&gt;otherSymbols.list = (ElfSymbol*)calloc(ret-&gt;otherSymbols.size, sizeof(Elf64_Sym) + NAME_BUFFER);</span><br><span class="line">   ptr = data + ret-&gt;sections[symTableIndex].sectionHeader.sh_offset;</span><br><span class="line">   for (int i = 0; i &lt; ret-&gt;otherSymbols.size; i++) &#123;</span><br><span class="line">       memcpy(&amp;ret-&gt;otherSymbols.list[i].symbol, ptr, sizeof(Elf64_Sym));    </span><br><span class="line">       ptr += sizeof(Elf64_Sym);</span><br><span class="line">       if (ret-&gt;otherSymbols.list[i].symbol.st_name == 0) &#123;</span><br><span class="line">           continue;    </span><br><span class="line">       &#125;</span><br><span class="line">       ret-&gt;otherSymbols.list[i].name = strdup(data + ret-&gt;sections[symTableNameIndex].sectionHeader.sh_offset</span><br><span class="line">           + ret-&gt;otherSymbols.list[i].symbol.st_name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Destroy-ELF-Data"><a href="#Destroy-ELF-Data" class="headerlink" title="Destroy ELF Data"></a>Destroy ELF Data</h1><h2 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(p);</span><br><span class="line">p = NULL;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/system-design-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/system-design-7/" itemprop="url">System Design 7</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-14T17:14:29+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SystemDesign/" itemprop="url" rel="index">
                    <span itemprop="name">SystemDesign</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>http / https 加密效率相对较低<br>rpc<br>protobuf 序列化，持久化，网络传输<br>thrift<br>系统设计 = 逻辑设计 + 架构设计<br>减少server的工作量，让driver report locations<br>为什么rider QPS远小于driver的？<br>rider不需要像司机那样实时汇报位置，原则上只有打车的时候需要汇报位置。即使为了调度车辆需要手机rider位置信息，其频率也是很低的。<br>为什么司机需要主动查trip table去找match自己的ride? 不是depatch模式吗<br>防止推送的信息丢失，因此保险起见在司机report的时候顺便返回给他匹配的trip。一般一个司机在某个时刻只会匹配一个trip，因此开销不大。<br>composite index<br>不能多个index都是范围的查询，效率低<br>数据按什么查询就按什么拆分</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/system-design-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/system-design-6/" itemprop="url">System Design 6 Distributed System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-14T17:14:20+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SystemDesign/" itemprop="url" rel="index">
                    <span itemprop="name">SystemDesign</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很难把pb级别放入内存，也就是hashmap可能不大行, 排序也可能不大行<br>使用外排序:<br>bloom filter 比 hash 所占内存小<br>slave server提供了CPU和内存</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/system-design-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/system-design-5/" itemprop="url">System Design 5 - Web Crawler & TypeHead</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-14T17:14:09+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SystemDesign/" itemprop="url" rel="index">
                    <span itemprop="name">SystemDesign</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebCrawler"><a href="#WebCrawler" class="headerlink" title="WebCrawler"></a>WebCrawler</h1><p>WebCrawler应该是多线程的爬取网页内容的工具, 爬取的网页数量很大并且每周都会有一个循环，这个信息的存储也会很大，通常会用GFS。</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Crawler_Structure.png?raw=true" alt="WebCrawler Structure"></p>
<h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><ul>
<li>How many web pages? </li>
<li>How long? </li>
<li>How Large?</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ul>
<li>Crawler</li>
<li>TaskService</li>
<li>StorageService</li>
</ul>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul>
<li>Use db to store tasks</li>
<li>BigTable to store web pages</li>
</ul>
<h2 id="Simple-Crawler"><a href="#Simple-Crawler" class="headerlink" title="Simple Crawler"></a>Simple Crawler</h2><ol>
<li>input: URL</li>
<li>Send an HTTP request and grab the content of the news list page</li>
<li>Extract all news titles from the news list page</li>
</ol>
<h2 id="Single-threaded-Web-Crawler"><a href="#Single-threaded-Web-Crawler" class="headerlink" title="Single-threaded Web Crawler"></a>Single-threaded Web Crawler</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/single-thread-web-crawler.png?raw=true" alt="Structure"><br>不断解析不断存储不断加入Queue中<br>producer and consumer model</p>
<h2 id="MultiThreaded-Web-Crawler-amp-Distributed-Web-Crawler"><a href="#MultiThreaded-Web-Crawler-amp-Distributed-Web-Crawler" class="headerlink" title="MultiThreaded Web Crawler &amp; Distributed Web Crawler"></a>MultiThreaded Web Crawler &amp; Distributed Web Crawler</h2><p>多个webcrawler同时工作。<br>Three different ways to work together:</p>
<ol>
<li>sleep</li>
<li>condition variable</li>
<li>semaphore<br>但不一定会提高performance。</li>
<li>context switch cost</li>
<li>thread port number limitation</li>
<li>network bottleneck for single machine<br>如果只按照queue的规则的话，那么有可能有些网页无法及时的爬取，导致信息的不均匀。设计tasktable来避免这一点。<br>有tasktable之后可以有一个messageQueue加锁来实现线程安全<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/tasktable.png?raw=true" alt="TaskTable"><br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/webcrawler+tasktable.png?raw=true" alt="Structure"></li>
</ol>
<h2 id="How-to-handle-slow-select"><a href="#How-to-handle-slow-select" class="headerlink" title="How to handle slow select"></a>How to handle slow select</h2><p>task table sharding 多个table同时进行，然后需要一个scheduler来进行管理。<br>爬虫的目标不是每个网页只爬一次(要求实时性)的话可能MQ无法保证，因为加到队尾会太长时间再次爬取<br>数据库存网页有没有抓过, task table priority queue timestamp 来看是否抓过, 使用一个db来存储下一次需要抓取的时间<br>这个过程慢一点没关系，offline 不服务用户</p>
<h2 id="How-to-handle-update-for-failure"><a href="#How-to-handle-update-for-failure" class="headerlink" title="How to handle update for failure"></a>How to handle update for failure</h2><p>Exponential back-off<br>success: crawl after 1 week<br>failure: crawl after 2 weeks<br>failure again: crawl after 4 weeks<br>…<br>保证了效率，不会总去爬失败的网页。</p>
<h2 id="How-to-handle-dead-cycle"><a href="#How-to-handle-dead-cycle" class="headerlink" title="How to handle dead cycle"></a>How to handle dead cycle</h2><p>One web has so many url, it will only crawl url in sina pages not others.<br>起始网页 seeds 链接多 新闻源网页<br>Use Quota! 为scheduler中每个网页提供一个限量</p>
<h2 id="Other-key-points"><a href="#Other-key-points" class="headerlink" title="Other key points"></a>Other key points</h2><p>inverted index 搜索引擎关键部分 查询基本不怎么用数据库, 效率低<br>网页之间有很多指向的关系，网页组成的节点<br>crawler 下载所有网页之后丢给GFS(效率大于DB), 拆开文章分成word,<br>inverted index 假的索引，查询引擎(query engine)<br>中文需要断句(word segmentation)<br>英文词态还原 likes-&gt;like<br>viterbi algorithm 分词算法<br>在query engine里做<br>bfs最好,dfs容易stackoverflow<br>crawler 抓完预渲染<br>多线程crawler<br>瓶颈在于加载网页<br>通过网页是否变化来推断timestamp<br>数据库实现队列<br>queue不应该只是先进先出<br>永远不要删数据！！！</p>
<hr>
<h1 id="TypeHead"><a href="#TypeHead" class="headerlink" title="TypeHead"></a>TypeHead</h1><h2 id="Scenario-1"><a href="#Scenario-1" class="headerlink" title="Scenario"></a>Scenario</h2><p>DAU 500m<br>Search: 4 <em> 6 </em> 500m = 12b(every user searches 6 times, types 4 letters)<br>QPS = 12b / 86400 = 138k<br>Peak QPS = 138k * 2 = 276k</p>
<h2 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h2><ol>
<li>QueryService</li>
<li>DataCollectionService</li>
</ol>
<h2 id="Storage-1"><a href="#Storage-1" class="headerlink" title="Storage"></a>Storage</h2><h3 id="For-QueryService"><a href="#For-QueryService" class="headerlink" title="For QueryService"></a>For QueryService</h3><p>数据库中like操作是非常expensive的，要用trie来进行优化<br>搜索引擎查询最好是key-value<br>Trie hashMap 效率 hashMap高 Trie省空间 性能差异<br>虽然expected time都是O(n)，但是trie的查找会在内存中跳来跳去<br>并不需要全部存完，可以只存top n的Words, 这个trie有in-memory的也有disk serialization的<br>当Trie太大了内存放不下的话，那么就需要把内存中trie的某些部分序列化之后存到磁盘中，要用的时候再反序列化取到内存中<br>一般就算是执行网页中的动态内容也会放在sandbox中的，不用担心会中毒。<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Typehead%20structure.png?raw=true" alt="TypeHead"></p>
<h3 id="For-DataCollectionService"><a href="#For-DataCollectionService" class="headerlink" title="For DataCollectionService"></a>For DataCollectionService</h3><p>dataCollectionService offline 统计query<br>相当于把query的活分一部分给data collection去做，来加速query<br>从log data里统计信息的，可以用BigTable</p>
<h2 id="How-to-qualify-this-system"><a href="#How-to-qualify-this-system" class="headerlink" title="How to qualify this system"></a>How to qualify this system</h2><ol>
<li>response time </li>
<li>result quality</li>
</ol>
<h2 id="How-to-reduce-response-time"><a href="#How-to-reduce-response-time" class="headerlink" title="How to reduce response time"></a>How to reduce response time</h2><ol>
<li>cache result</li>
<li>pre-fetch</li>
</ol>
<h2 id="What-if-trie-gets-too-large"><a href="#What-if-trie-gets-too-large" class="headerlink" title="What if trie gets too large"></a>What if trie gets too large</h2><p>Sharding trie, 多个queryservice一起工作, 用consistent hashing来决定具体的string在哪个机器上。<br>trie sharding 不能用单词开头sharding 有可能一个上面特别多<br>prefic sharding<br>sharding 和 QPS 有关，和trie、hashmap无关</p>
<h2 id="How-to-reduce-size-of-log-file"><a href="#How-to-reduce-size-of-log-file" class="headerlink" title="How to reduce size of log file"></a>How to reduce size of log file</h2><p>Probalilistic Logging<br>就是每来一次搜索我就扔一次骰子(随机数)，如果扔到了特定的数字就log， 否则就忽略。<br>每个log文件的保留都要有个概率，比如1/1000，这样就能显著减少file量。</p>
<h2 id="爬虫的效率不影响搜索引擎的效率么？"><a href="#爬虫的效率不影响搜索引擎的效率么？" class="headerlink" title="爬虫的效率不影响搜索引擎的效率么？"></a>爬虫的效率不影响搜索引擎的效率么？</h2><p>只会影响搜索结果的时效性，但是不会影响到向用户返回结果的效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/system-design-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/system-design-2/" itemprop="url">System Design 2 Design User System - DataBase & Memcache</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-14T13:32:26+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SystemDesign/" itemprop="url" rel="index">
                    <span itemprop="name">SystemDesign</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Scenario-and-Services-想一想情景是什么，需要实现什么功能"><a href="#Scenario-and-Services-想一想情景是什么，需要实现什么功能" class="headerlink" title="Scenario and Services (想一想情景是什么，需要实现什么功能)"></a>Scenario and Services (想一想情景是什么，需要实现什么功能)</h1><p><strong>情景决定功能</strong></p>
<p><strong>A simple one will include these basic functions</strong></p>
<ol>
<li>User registration (用户注册) write op</li>
<li>LogIn (登陆)</li>
<li>Search for user information (查询) read op</li>
<li>Store friendship info</li>
</ol>
<p><strong>The number of write op and read op will determine the design of system. When we want to design a system common used by user(people). it will have more read op than write op. Vice versa for machine used system.</strong><br><strong>人用的读多写少，机器用的写多读少</strong></p>
<p><strong>DAU(Daily Active User)</strong><br><strong>QPS(Quries Per Seconds)</strong> 决定数据存储系统的选择<br><strong>一天的时间 86400s</strong> 为了计算方便可以 ~ 100k</p>
<p><strong>注册，登录，信息修改 QPS 约</strong> </p>
<ul>
<li>100M * 0.1 / 86400 ~ 100 </li>
<li>0.1 = 平均每个用户每天登录+注册+信息修改 </li>
<li>Peak = 100 * 3 = 300 3 为预估值</li>
</ul>
<p><strong>查询的QPS 约</strong></p>
<ul>
<li>100 M * 100 / 86400 ~ 100k</li>
<li>100 = 平均每个用户每天与查询用户信息相关的操作次数(查看好友，发信息，更新消息主页)</li>
<li>Peak = 100k * 3 = 300 k</li>
</ul>
<h2 id="DataBase-Choice-based-by-QPS"><a href="#DataBase-Choice-based-by-QPS" class="headerlink" title="DataBase Choice based by QPS"></a>DataBase Choice based by QPS</h2><ul>
<li>MySQL —— 1k (relation type)</li>
<li>MongoDB / Cassandra —— 10k (disk type)</li>
<li>Redis(数据持久化) / Memcached(非数据持久化) —— 100k ~ 1M (cache type)</li>
</ul>
<hr>
<ul>
<li>读多写少的系统一定要用cache进行优化</li>
<li>file system cpu client browser 都有cache</li>
<li>优化DB查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class UserService:</span><br><span class="line">    </span><br><span class="line">    def getUser(self, user_id):</span><br><span class="line">        user = cache.get(user_id)</span><br><span class="line">        if user:</span><br><span class="line">            return user</span><br><span class="line">        user = database.get(user_id)</span><br><span class="line">        cache.set(user_id, user)</span><br><span class="line">        return user</span><br><span class="line"></span><br><span class="line">    def setUser(self, user) &#123;</span><br><span class="line">        cache.delete(user.id)</span><br><span class="line">        database.set(user)    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Authentication-Service"><a href="#Authentication-Service" class="headerlink" title="Authentication Service"></a>Authentication Service</h2><h3 id="Session-amp-cookie"><a href="#Session-amp-cookie" class="headerlink" title="Session &amp; cookie"></a>Session &amp; cookie</h3><ol>
<li>用户login之后会创建Session对象（server端）</li>
<li>返回session_key值到browser</li>
<li>这个值被browser记录在cookie中</li>
<li>用户再次访问的时候会带上这个网站上所有的cookie（session_key）</li>
<li>服务器检测session_key有效就认为用户登录</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>SessionTable</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>session key</td>
<td>string</td>
<td>hash值 全局唯一 无规律</td>
</tr>
<tr>
<td>user_id</td>
<td>foreign key</td>
<td>指向 user table 用来找user</td>
</tr>
<tr>
<td>expired_at</td>
<td>timeStamp</td>
<td>什么时候过期</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>这个table存在哪里都可以的，存在database可以持久一点，cache的话速度快 如果单点故障就让全部用户重新登录就好</li>
</ul>
<hr>
<p><strong>读写都很多怎么办?</strong></p>
<ol>
<li>增加机器分摊流量</li>
<li>使用Redis(cache-through) 读写都快 Memecached(cache-aside)</li>
</ol>
<ul>
<li>cache-aside: DB 和 cache 通过web server 进行沟通 memcached + mysql</li>
<li>cache-through: server只和cache沟通，cache和DB沟通 redis(DB + Cache)</li>
</ul>
<hr>
<h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><h2 id="FriendShip-Service"><a href="#FriendShip-Service" class="headerlink" title="FriendShip Service"></a>FriendShip Service</h2><ol>
<li>存为一条信息 查询一次</li>
<li>存为两条信息 查询两次</li>
</ol>
<p><strong>NoSQL很多事都要自己去做，有transaction不能选择NoSQL</strong></p>
<h3 id="Example-Cassandra"><a href="#Example-Cassandra" class="headerlink" title="Example Cassandra"></a>Example Cassandra</h3><ol>
<li>row_key: hashKey</li>
<li>column_key: sorted enable range query 可以是复合值 query(row_key, column_start, column_end)</li>
<li>value: String 许多信息时 Serialization </li>
</ol>
<p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/friendship.png?raw=true" alt="alt text" title="Friendship Example"></p>
<p><strong>user table 用SQL</strong></p>
<hr>
<h1 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h1><h2 id="Single-point-failure"><a href="#Single-point-failure" class="headerlink" title="Single point failure"></a>Single point failure</h2><ul>
<li>数据拆分 Sharding (NoSQL自带， MySQL不带)<br>  按照一定的规则，将数据拆分成不同的部分，保存在不同的机器上<br>  这样就算挂也不会导致网站 100% 不可用</li>
<li>数据备份 Replica<br>  通常的做法是一式三份(重要的事情“写”三遍)<br>  Replica 同时还能分摊读请求</li>
</ul>
<ul>
<li>vertical sharding 不同数据放到不同机器 </li>
<li>Horizontal Sharding 重点！！！普通的hash分配数据时添加机器会发生数据大迁移, 这个属于nonconsistent hashing</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/graph/" itemprop="url">Graph Theory - BFS & Union Find & Others</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-14T13:23:30+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本文总结一下graph的题，图的题好多公司喜欢考，比如Google和intuit，还是需要总结一下常见的题的。</p>
<hr>
<h1 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a>Course Schedule</h1><p><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Course Schedule</a><br>普通的拓扑排序，建立入度数组，根据每个点的入度值来加入queue中，最后进行判断即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">        int[] degree = new int[numCourses];</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            topo.put(i, new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] pre : prerequisites) &#123;</span><br><span class="line">            topo.get(pre[1]).add(pre[0]);</span><br><span class="line">            degree[pre[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if (degree[i] == 0) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                degree[i]--; // this is important avoid loop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            int temp = q.poll();</span><br><span class="line">            count++;</span><br><span class="line">            List&lt;Integer&gt; list = topo.get(temp);</span><br><span class="line">            for (int item : list) &#123;</span><br><span class="line">                degree[item]--;</span><br><span class="line">                if (degree[item] == 0) &#123;</span><br><span class="line">                    q.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Graph-Valid-Tree"><a href="#Graph-Valid-Tree" class="headerlink" title="Graph Valid Tree"></a>Graph Valid Tree</h1><p><a href="https://leetcode.com/problems/graph-valid-tree/description/" target="_blank" rel="noopener">Graph Valid Tree</a><br>判断是不是valid tree就是要判断存不存在环，并且看root是不是只有一个。判断环可以用UnionFind，判断root的话，先初始化count，如果发生union就减一，这样最后判断count是否为0就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">    int[] father;</span><br><span class="line">    int count;</span><br><span class="line">    public UnionFind(int n) &#123;</span><br><span class="line">        father = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        count = n;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int a) &#123;</span><br><span class="line">        if (father[a] &lt; 0) &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        father[a] = find(father[a]);</span><br><span class="line">        return father[a];</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int a, int b) &#123;</span><br><span class="line">        a = find(a);</span><br><span class="line">        b = find(b);</span><br><span class="line">        if (a != b) &#123;</span><br><span class="line">            if (father[a] &lt; father[b]) &#123;</span><br><span class="line">                father[a] += father[b];</span><br><span class="line">                father[b] = a;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                father[b] += father[a];</span><br><span class="line">                father[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean validTree(int n, int[][] edges) &#123;</span><br><span class="line">        UnionFind uf = new UnionFind(n);</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            int a = uf.find(edge[0]);</span><br><span class="line">            int b = uf.find(edge[1]);</span><br><span class="line">            if (a == b) &#123;</span><br><span class="line">                return false; // 是否有环</span><br><span class="line">            &#125;</span><br><span class="line">            uf.union(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        return uf.count == 1; // 是否root只有一个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Alien-Dictionary"><a href="#Alien-Dictionary" class="headerlink" title="Alien Dictionary"></a>Alien Dictionary</h1><p><a href="https://leetcode.com/problems/alien-dictionary/description/" target="_blank" rel="noopener">Alien Dictionary</a><br>这个题是典型的拓扑排序的问题，先初始化所有的字符，然后根据前后两个单词第一个不一样的字母来建立拓扑关系，然后输出相应的拓扑顺序即可，至少做10遍把。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        if (words == null || words.length == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, List&lt;Character&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; degree = new HashMap&lt;&gt;();</span><br><span class="line">        for (String word : words) &#123; // initialization</span><br><span class="line">            for (Character c : word.toCharArray()) &#123;</span><br><span class="line">                topo.putIfAbsent(c, new ArrayList&lt;&gt;());</span><br><span class="line">                degree.putIfAbsent(c, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = words.length;</span><br><span class="line">        for (int i = 0; i + 1 &lt; n; i++) &#123;</span><br><span class="line">            int len = Math.min(words[i].length(), words[i + 1].length());</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                char c1 = words[i].charAt(j);</span><br><span class="line">                char c2 = words[i + 1].charAt(j);</span><br><span class="line">                if (c1 != c2) &#123;</span><br><span class="line">                    topo.get(c1).add(c2);</span><br><span class="line">                    degree.put(c2, degree.get(c2) + 1); // topo build graph</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Character&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        for (Character c : degree.keySet()) &#123;</span><br><span class="line">            if (degree.get(c) == 0) &#123;</span><br><span class="line">                q.add(c);</span><br><span class="line">                degree.put(c, -1); // this is important</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            char c = q.poll();</span><br><span class="line">            sb.append(c);</span><br><span class="line">            for (char item : topo.get(c)) &#123;</span><br><span class="line">                degree.put(item, degree.get(item) - 1);</span><br><span class="line">                if (degree.get(item) == 0) &#123;</span><br><span class="line">                    q.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.length() == topo.size() ? sb.toString() : &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Minimum-Height-Trees"><a href="#Minimum-Height-Trees" class="headerlink" title="Minimum Height Trees"></a>Minimum Height Trees</h1><p><a href="https://leetcode.com/problems/minimum-height-trees/description/" target="_blank" rel="noopener">Minimum Height Trees</a><br>这个题的意思是找到一个结点然后让它作为root，可以让整个树有最小的高度，通过分析可知，这样的点在树中最多有两个，我们采用剥洋葱的方式，不断去除叶子结点，最后留下的两个或者一个结点就是相应的root，有种bfs的意思，本质还是拓扑排序，根据连接结点的个数来判断是否为leaf结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            res.add(0);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 0 || edges.length == 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            topo.put(i, new HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            topo.get(edge[0]).add(edge[1]);</span><br><span class="line">            topo.get(edge[1]).add(edge[0]); // undirected graph </span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; leaves = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (topo.get(i).size() == 1) &#123;</span><br><span class="line">                leaves.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (n &gt; 2) &#123;</span><br><span class="line">            n -= leaves.size();</span><br><span class="line">            List&lt;Integer&gt; newLeaves = new ArrayList&lt;&gt;();</span><br><span class="line">            for (int leaf : leaves) &#123;</span><br><span class="line">                for (int i : topo.get(leaf)) &#123;</span><br><span class="line">                    topo.get(i).remove(leaf);</span><br><span class="line">                    if (topo.get(i).size() == 1) &#123;</span><br><span class="line">                        newLeaves.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            leaves = newLeaves;</span><br><span class="line">        &#125;</span><br><span class="line">        return leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Reconstruct-Itinerary"><a href="#Reconstruct-Itinerary" class="headerlink" title="Reconstruct Itinerary"></a>Reconstruct Itinerary</h1><p><a href="https://leetcode.com/problems/reconstruct-itinerary/description/" target="_blank" rel="noopener">Reconstruct Itinerary</a><br>这个题需要建图然后dfs，backtracking所有的可能，如果出现一个可能就返回结果，能这样的唯一方法就是要设置全局变量，控制回溯的发生，这个题还是要多练一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">    int numOfTicket = 0;</span><br><span class="line">    int n = 0;</span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; findItinerary(String[][] tickets) &#123;</span><br><span class="line">        numOfTicket = tickets.length;</span><br><span class="line">        for (String[] ticket : tickets) &#123;</span><br><span class="line">            topo.putIfAbsent(ticket[0], new LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (String[] ticket : tickets) &#123;</span><br><span class="line">            topo.get(ticket[0]).add(ticket[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (String str : topo.keySet()) &#123;</span><br><span class="line">            Collections.sort(topo.get(str));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(&quot;JFK&quot;);</span><br><span class="line">        dfs(&quot;JFK&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(String start) &#123;</span><br><span class="line">        if (!topo.containsKey(start)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = topo.get(start);</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            String str = list.get(i);</span><br><span class="line">            res.add(str);</span><br><span class="line">            list.remove(i);</span><br><span class="line">            dfs(str);</span><br><span class="line">            if (n == numOfTicket) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">            res.remove(res.size() - 1);</span><br><span class="line">            list.add(i, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Evaluate-Division"><a href="#Evaluate-Division" class="headerlink" title="Evaluate Division"></a>Evaluate Division</h1><p><a href="https://leetcode.com/problems/evaluate-division/description/" target="_blank" rel="noopener">Evaluate Division</a><br>这个题是真的好，是一个带权值的无向图，增加了复杂度，之前没有做过类似的，所以不知道怎么表示边的同时表示权值，所以还是要写个十遍应该就可以了, 注意不光要记录正向也要记录反向，然后dfs即可。真的好题！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; pairs = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;Double&gt;&gt; valuesPair = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; equations.length; i++) &#123;</span><br><span class="line">            String[] equation = equations[i];</span><br><span class="line">            if (!pairs.containsKey(equation[0])) &#123;</span><br><span class="line">                pairs.put(equation[0], new ArrayList&lt;&gt;());</span><br><span class="line">                valuesPair.put(equation[0], new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            if (!pairs.containsKey(equation[1])) &#123;</span><br><span class="line">                pairs.put(equation[1], new ArrayList&lt;&gt;());</span><br><span class="line">                valuesPair.put(equation[1], new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            pairs.get(equation[0]).add(equation[1]);</span><br><span class="line">            pairs.get(equation[1]).add(equation[0]);</span><br><span class="line">            valuesPair.get(equation[0]).add(values[i]);</span><br><span class="line">            valuesPair.get(equation[1]).add(1 / values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        double[] result = new double[queries.length];</span><br><span class="line">        for (int i = 0; i &lt; queries.length; i++) &#123;</span><br><span class="line">            String[] query = queries[i];</span><br><span class="line">            result[i] = dfs(query[0], query[1], pairs, valuesPair, new HashSet&lt;&gt;(), 1.0);</span><br><span class="line">            if (result[i] == 0.0) &#123;</span><br><span class="line">                result[i] = -1.0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private double dfs(String start, String end, Map&lt;String, List&lt;String&gt;&gt; pairs, </span><br><span class="line">                       Map&lt;String, List&lt;Double&gt;&gt; values, Set&lt;String&gt; set, double value) &#123;</span><br><span class="line">        if (set.contains(start)) &#123;</span><br><span class="line">            return 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!pairs.containsKey(start)) &#123;</span><br><span class="line">            return 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (start.equals(end)) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(start);</span><br><span class="line">        List&lt;String&gt; strList = pairs.get(start);</span><br><span class="line">        List&lt;Double&gt; valueList = values.get(start);</span><br><span class="line">        double tmp = 0.0;</span><br><span class="line">        for (int i = 0; i &lt; strList.size(); i++) &#123;</span><br><span class="line">            tmp = dfs(strList.get(i), end, pairs, values, set, value * valueList.get(i));</span><br><span class="line">            if (tmp != 0.0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set.remove(start);</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Redundant-Connection-II"><a href="#Redundant-Connection-II" class="headerlink" title="Redundant Connection II"></a>Redundant Connection II</h1><p><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">Redundant Connection II</a><br>这个题还是要冷静分析一下的，跟I不同，这个题是有向图，如果要构成tree，一个结点不能有两个父节点，这个树中不能有环。如果我们可以移除一条边，让这个tree valid的话，那么就只能存在一个入度为2的节点，我们把两个edge作为candidate存起来，然后用unionfind进行查找，如果出现了环，并且图中没有candidate，可以直接返回构成环的edge，否则返回第一个candidate，最后如果都是valid的话，就返回第二个candidate, 感慨牛逼啊。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] findRedundantDirectedConnection(int[][] edges) &#123;</span><br><span class="line">        int[] can1 = &#123;-1, -1&#125;;</span><br><span class="line">        int[] can2 = &#123;-1, -1&#125;;</span><br><span class="line">        int[] parent = new int[edges.length + 1];</span><br><span class="line">        for (int i = 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            if (parent[edges[i][1]] == 0) &#123;</span><br><span class="line">                parent[edges[i][1]] = edges[i][0];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                can2 = new int[] &#123;edges[i][0], edges[i][1]&#125;;</span><br><span class="line">                can1 = new int[] &#123;parent[edges[i][1]], edges[i][1]&#125;;</span><br><span class="line">                edges[i][1] = 0;//set invalid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125; // 初始化union find</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            if (edges[i][1] == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; // 遇见第二个让edge[1]成为入度为2的点</span><br><span class="line">            int child = edges[i][1];</span><br><span class="line">            int father = edges[i][0];</span><br><span class="line">            if (root(parent, father) == child) &#123; // 有环</span><br><span class="line">                if (can1[0] == -1) &#123; // 没有candidate</span><br><span class="line">                    return edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">                return can1;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[child] = father; // union </span><br><span class="line">        &#125;</span><br><span class="line">        return can2;</span><br><span class="line">    &#125;</span><br><span class="line">    int root(int[] parent, int i) &#123;</span><br><span class="line">        while (i != parent[i]) &#123;</span><br><span class="line">            parent[i] = parent[parent[i]];</span><br><span class="line">            i = parent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Couples-Holding-Hands"><a href="#Couples-Holding-Hands" class="headerlink" title="Couples Holding Hands"></a>Couples Holding Hands</h1><p><a href="https://leetcode.com/problems/couples-holding-hands/description/" target="_blank" rel="noopener">Couples Holding Hands</a><br>这个题也要使用unionfind，一旦出现不匹配的情况就进行union，这样就模拟了交换的次数，注意初始化unionfind的时候是初始化一半的数量的，这样相邻两个数的root才能是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">    public int[] father;</span><br><span class="line">    public int count;</span><br><span class="line">    public UnionFind(int n) &#123;</span><br><span class="line">        father = new int[n];</span><br><span class="line">        Arrays.fill(father, -1);</span><br><span class="line">        count = n;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int x) &#123;</span><br><span class="line">        if (father[x] &lt; 0) &#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        return father[x] = find(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int a, int b) &#123;</span><br><span class="line">        a = find(a);</span><br><span class="line">        b = find(b);</span><br><span class="line">        if (a != b) &#123;</span><br><span class="line">            if (father[a] &lt; father[b]) &#123;</span><br><span class="line">                father[a] += father[b];</span><br><span class="line">                father[b] = a;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                father[b] += father[a];</span><br><span class="line">                father[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int minSwapsCouples(int[] row) &#123;</span><br><span class="line">        int N = row.length / 2;</span><br><span class="line">        UnionFind uf = new UnionFind(N);</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            int a = row[2 * i];</span><br><span class="line">            int b = row[2 * i + 1];</span><br><span class="line">            uf.union(a / 2, b / 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return N - uf.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Is-Graph-Bipartite"><a href="#Is-Graph-Bipartite" class="headerlink" title="Is Graph Bipartite?"></a>Is Graph Bipartite?</h1><p><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">Is Graph Bipartite?</a><br>这个题是典型的bfs染色节点的问题，因为只有两个颜色，所以可以用类似滚动数组的方法，注意corner case 是每一个节点都要染色，不能一开始只加一个没染色的进去，这样可能会漏掉一大部分另外的图，图有可能是seperate的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBipartite(int[][] graph) &#123;</span><br><span class="line">        int n = graph.length;</span><br><span class="line">        int[] color = new int[n];</span><br><span class="line">        Arrays.fill(color, -1);</span><br><span class="line">        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (color[i] == -1) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                color[i] = 0;</span><br><span class="line">                while (!q.isEmpty()) &#123;</span><br><span class="line">                    int size = q.size();</span><br><span class="line">                    for (int k = 0; k &lt; size; k++) &#123;</span><br><span class="line">                        int temp = q.poll();</span><br><span class="line">                        int col = color[temp];</span><br><span class="line">                        for (int item : graph[temp]) &#123;</span><br><span class="line">                            if (color[item] == col) &#123;</span><br><span class="line">                                return false;</span><br><span class="line">                            &#125; else if (color[item] == -1) &#123;</span><br><span class="line">                                color[item] = 1 - col;</span><br><span class="line">                                q.add(item);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Find-Eventual-Safe-States"><a href="#Find-Eventual-Safe-States" class="headerlink" title="Find Eventual Safe States"></a>Find Eventual Safe States</h1><p><a href="https://leetcode.com/problems/find-eventual-safe-states/description/" target="_blank" rel="noopener">Find Eventual Safe States</a><br>dfs染色问题，我们要判断每个点是不是terminate的，就是它是否在一个环里，如果在环里就不是一个terminate节点，用染色方法来判断是否产生了环，访问过之后把它变为gray，如果dfs过程中再次出现gray的点，就是一个环的出现，如果没有，设为black，为terminate点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123;</span><br><span class="line">        int n = graph.length;</span><br><span class="line">        int[] color = new int[n];</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (dfs(i, graph, color)) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // gray : 1 black 2</span><br><span class="line">    public boolean dfs(int node, int[][] graph, int[] color) &#123;</span><br><span class="line">        if (color[node] &gt; 0) &#123; // if it is visited, determine whether it is a terminate node</span><br><span class="line">            return color[node] == 2;</span><br><span class="line">        &#125;</span><br><span class="line">        color[node] = 1; // set it as visited</span><br><span class="line">        for (int temp : graph[node]) &#123;</span><br><span class="line">            if (color[temp] == 2) &#123; // if the neighbor is terminate node. continue, our goal is find cycle</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (color[temp] == 1 || !dfs(temp, graph, color)) &#123; // if it is visited or visit it again</span><br><span class="line">                return false; // it is a cycle</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[node] = 2; // it is a terminate node</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Regions-Cut-By-Slashes"><a href="#Regions-Cut-By-Slashes" class="headerlink" title="Regions Cut By Slashes"></a>Regions Cut By Slashes</h1><p><a href="https://leetcode.com/problems/regions-cut-by-slashes/description/" target="_blank" rel="noopener">Regions Cut By Slashes</a><br>好题，这个题非常巧妙的运用了unionfind的方法，把每个单元格分为四个小块，然后根据出现的字符来union四个小块，这是单元格内的，之后就是合并单元格之间的，合并完之后再次调用find来计数就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">    int[] father;</span><br><span class="line">    public UnionFind(int n) &#123;</span><br><span class="line">        father = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int a) &#123;</span><br><span class="line">        if (father[a] == a) &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        return father[a] = find(father[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int a, int b) &#123;</span><br><span class="line">        a = find(a);</span><br><span class="line">        b = find(b);</span><br><span class="line">        if (a != b) &#123;</span><br><span class="line">            father[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int regionsBySlashes(String[] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        UnionFind uf = new UnionFind(4 * n * n);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                char c = grid[i].charAt(j);</span><br><span class="line">                int root = 4 * (i * n + j);</span><br><span class="line">                switch(c) &#123;</span><br><span class="line">                    case &apos;\\&apos;:</span><br><span class="line">                        uf.union(root + 0, root + 1);</span><br><span class="line">                        uf.union(root + 2, root + 3);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;/&apos;:</span><br><span class="line">                        uf.union(root + 0, root + 3);</span><br><span class="line">                        uf.union(root + 1, root + 2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos; &apos;:</span><br><span class="line">                        uf.union(root + 0, root + 1);</span><br><span class="line">                        uf.union(root + 1, root + 2);</span><br><span class="line">                        uf.union(root + 2, root + 3);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    uf.union(root + 2, root + 4 * n + 0);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    uf.union(root + 1, root + 4 + 3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4 * n * n; i++) &#123;</span><br><span class="line">            if (uf.find(i) == i) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Shangzhen Wu</p>
              <p class="site-description motion-element" itemprop="description">This is a personal learning blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shangzhen Wu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
