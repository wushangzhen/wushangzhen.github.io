<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="This is a personal learning blog">
<meta name="keywords" content="Algorithm, Computer">
<meta property="og:type" content="website">
<meta property="og:title" content="Shangzhen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Shangzhen&#39;s Blog">
<meta property="og:description" content="This is a personal learning blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shangzhen&#39;s Blog">
<meta name="twitter:description" content="This is a personal learning blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Shangzhen's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shangzhen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/ListNode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/07/ListNode/" itemprop="url">ListNode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-08T09:07:16+08:00">
                2019-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这篇总结一下ListNode的题，这种题面试还是挺经常考的，易错高频，之前总结的不多，发现有些题还是非常巧妙的。</p>
<hr>
<h1 id="Add-Two-Numbers-II"><a href="#Add-Two-Numbers-II" class="headerlink" title="Add Two Numbers II"></a>Add Two Numbers II</h1><p><a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">Add Two Numbers II</a><br>这个题和Add Two Numbers的唯一不同就是，顺序的序列是反过来的，我觉得任何顺序反过来的题目感觉和逻辑相反的，都可以用stack来解决一下, 如果可以改变input，也可以用reverse linkedlist来变为add two numbers 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if (l1 == null) &#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l2 == null) &#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stk1 = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; stk2 = new Stack&lt;&gt;();</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        while (p1 != null) &#123;</span><br><span class="line">            stk1.push(p1);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (p2 != null) &#123;</span><br><span class="line">            stk2.push(p2);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        while (!stk1.isEmpty() || !stk2.isEmpty()) &#123;</span><br><span class="line">            int a = stk1.isEmpty() ? 0 : stk1.pop().val;</span><br><span class="line">            int b = stk2.isEmpty() ? 0 : stk2.pop().val;</span><br><span class="line">            int sum = a + b + carry;</span><br><span class="line">            carry = sum / 10;</span><br><span class="line">            int digit = sum % 10;</span><br><span class="line">            ListNode newNode = new ListNode(digit);</span><br><span class="line">            ListNode temp = dummy.next;</span><br><span class="line">            dummy.next = newNode;</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry == 1) &#123;</span><br><span class="line">            ListNode newNode = new ListNode(carry);</span><br><span class="line">            ListNode temp = dummy.next;</span><br><span class="line">            dummy.next = newNode;</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h1><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">Swap Nodes in Pairs</a><br>这个题和那个swap k nodes 很像，所以完全可以按一个招式解。题目的策略就是每找到一段符合要求的listnode串就进行reverselinkedlist的翻转，所以reverse linkedlist是重中之重，注意传入参数的时候要传入dummy节点和end的节点，这样就可以确定翻转串之后的结尾，返回值要返回start, 这样就可以更新dummy节点，继续向下递归即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = 2;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode last = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            int count = k - 1;</span><br><span class="line">            while (count != 0) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                if (cur == null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            // cur maybe null</span><br><span class="line">            last = reverseKNodes(last, cur);</span><br><span class="line">            cur = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode reverseKNodes(ListNode last, ListNode end) &#123;</span><br><span class="line">        ListNode start = last.next;</span><br><span class="line">        ListNode cur = start.next;</span><br><span class="line">        ListNode l = start;</span><br><span class="line">        if (end == null) &#123;</span><br><span class="line">            return start;</span><br><span class="line">        &#125;</span><br><span class="line">        // 1-&gt;2-&gt;3 3-&gt;2-&gt;1</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        // pay attention to the reverse</span><br><span class="line">        while (start.next != next) &#123;</span><br><span class="line">            l.next = cur.next;</span><br><span class="line">            cur.next = last.next;</span><br><span class="line">            last.next = cur;</span><br><span class="line">            ListNode n = l.next;</span><br><span class="line">            l = cur;</span><br><span class="line">            cur = n;</span><br><span class="line">        &#125;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a>Rotate List</h1><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">Rotate List</a><br>这个题就是找到要翻转节点的前一个节点然后把它后面的节点移到前面就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k % count == 0) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            k = k % count;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        while (k != -1) &#123; // pay attention to the this number</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast != null) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = dummy.next;</span><br><span class="line">        dummy.next = slow.next;</span><br><span class="line">        slow.next = null;</span><br><span class="line">        ListNode tail = dummy;</span><br><span class="line">        while (tail.next != null) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = temp;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a>Remove Duplicates from Sorted List II</h1><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="noopener">Remove Duplicates from Sorted List II</a><br>双指针去重，两层循环注意内层循环要判断是否为null，如果slow和fast之间相差大于1就说明他有重复的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        while (fast != null) &#123;</span><br><span class="line">            while (fast != null &amp;&amp; fast.val == slow.val) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (slow.next == fast) &#123;</span><br><span class="line">                cur.next = slow;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                cur.next = null;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = fast;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h1><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">Partition List</a><br>这个题inplace并不好做，还是老实的建立两个dummy节点，分别拼接不同的节点，最后合并起来就好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode partition(ListNode head, int x) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy1 = new ListNode(0);</span><br><span class="line">        ListNode dummy2 = new ListNode(0);</span><br><span class="line">        ListNode p1 = dummy1;</span><br><span class="line">        ListNode p2 = dummy2;</span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">            if (head.val &lt; x) &#123;</span><br><span class="line">                p1.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p1.next = null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p2.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">                p2.next = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = dummy2.next;</span><br><span class="line">        return dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h1><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="noopener">Copy List with Random Pointer</a><br>一般deep copy的主要做法是维护一个map存每个节点的副本，会耗费O(n)的空间，这个题先写一下map版本的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode head0 = head;</span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">            if (!memo.containsKey(head)) &#123;</span><br><span class="line">                memo.put(head, new RandomListNode(head.label));</span><br><span class="line">            &#125;</span><br><span class="line">            if (head.next != null) &#123;</span><br><span class="line">                if (!memo.containsKey(head.next)) &#123;</span><br><span class="line">                    memo.put(head.next, new RandomListNode(head.next.label));</span><br><span class="line">                &#125;</span><br><span class="line">                memo.get(head).next = memo.get(head.next);</span><br><span class="line">            &#125;</span><br><span class="line">            if (head.random != null) &#123;</span><br><span class="line">                if (!memo.containsKey(head.random)) &#123;</span><br><span class="line">                    memo.put(head.random, new RandomListNode(head.random.label));</span><br><span class="line">                &#125;</span><br><span class="line">                memo.get(head).random = memo.get(head.random);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return memo.get(head0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个题可以用O(1)的空间，首先在每个节点最后复制每个节点，A-&gt;B-&gt;C &gt; A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’<br>这样我们就可以维护一个前后的关系，即保护了next的关系，下一步我们要处理random的pointer<br>处理完了之后就把这条链broke up成两条链，返回新链就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode p = head;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            RandomListNode newNode = new RandomListNode(p.label);</span><br><span class="line">            newNode.next = p.next;</span><br><span class="line">            p.next = newNode;</span><br><span class="line">            p = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            p.next.random = (p.random == null) ? null : p.random.next;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        RandomListNode newHead = p.next;</span><br><span class="line">        RandomListNode p2 = newHead;</span><br><span class="line">        while (p2.next != null) &#123;</span><br><span class="line">            p.next = p2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">            p2.next = p2.next.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = p2.next;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h1><p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Linked List Cycle</a><br>快慢指针两种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (fast != slow);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a>Linked List Cycle II</h1><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">Linked List Cycle II</a><br>快慢指针，相遇之后一个一个指针重返开头，再次相遇即为cycle的起点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fast == null || fast.next == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        while (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/system-design-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/06/system-design-6/" itemprop="url">System Design 6 Distributed System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-07T14:58:51+08:00">
                2019-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/System-Design/" itemprop="url" rel="index">
                    <span itemprop="name">System Design</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很难把pb级别放入内存，也就是hashmap可能不大行, 排序也可能不大行<br>使用外排序:<br>bloom filter 比 hash 所占内存小<br>slave server提供了CPU和内存</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/system-design-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/06/system-design-5/" itemprop="url">System Design 5 - Web Crawler & TypeHead</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-07T14:52:16+08:00">
                2019-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/System-Design/" itemprop="url" rel="index">
                    <span itemprop="name">System Design</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebCrawler"><a href="#WebCrawler" class="headerlink" title="WebCrawler"></a>WebCrawler</h1><p>WebCrawler应该是多线程的爬取网页内容的工具, 爬取的网页数量很大并且每周都会有一个循环，这个信息的存储也会很大，通常会用GFS。</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Crawler_Structure.png?raw=true" alt="WebCrawler Structure"></p>
<h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><ul>
<li>How many web pages? </li>
<li>How long? </li>
<li>How Large?</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ul>
<li>Crawler</li>
<li>TaskService</li>
<li>StorageService</li>
</ul>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul>
<li>Use db to store tasks</li>
<li>BigTable to store web pages</li>
</ul>
<h2 id="Simple-Crawler"><a href="#Simple-Crawler" class="headerlink" title="Simple Crawler"></a>Simple Crawler</h2><ol>
<li>input: URL</li>
<li>Send an HTTP request and grab the content of the news list page</li>
<li>Extract all news titles from the news list page</li>
</ol>
<h2 id="Single-threaded-Web-Crawler"><a href="#Single-threaded-Web-Crawler" class="headerlink" title="Single-threaded Web Crawler"></a>Single-threaded Web Crawler</h2><p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/single-thread-web-crawler.png?raw=true" alt="Structure"><br>不断解析不断存储不断加入Queue中<br>producer and consumer model</p>
<h2 id="MultiThreaded-Web-Crawler-amp-Distributed-Web-Crawler"><a href="#MultiThreaded-Web-Crawler-amp-Distributed-Web-Crawler" class="headerlink" title="MultiThreaded Web Crawler &amp; Distributed Web Crawler"></a>MultiThreaded Web Crawler &amp; Distributed Web Crawler</h2><p>多个webcrawler同时工作。<br>Three different ways to work together:</p>
<ol>
<li>sleep</li>
<li>condition variable</li>
<li>semaphore<br>但不一定会提高performance。</li>
<li>context switch cost</li>
<li>thread port number limitation</li>
<li>network bottleneck for single machine<br>如果只按照queue的规则的话，那么有可能有些网页无法及时的爬取，导致信息的不均匀。设计tasktable来避免这一点。<br>有tasktable之后可以有一个messageQueue加锁来实现线程安全<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/tasktable.png?raw=true" alt="TaskTable"><br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/webcrawler+tasktable.png?raw=true" alt="Structure"></li>
</ol>
<h2 id="How-to-handle-slow-select"><a href="#How-to-handle-slow-select" class="headerlink" title="How to handle slow select"></a>How to handle slow select</h2><p>task table sharding 多个table同时进行，然后需要一个scheduler来进行管理。<br>爬虫的目标不是每个网页只爬一次(要求实时性)的话可能MQ无法保证，因为加到队尾会太长时间再次爬取<br>数据库存网页有没有抓过, task table priority queue timestamp 来看是否抓过, 使用一个db来存储下一次需要抓取的时间<br>这个过程慢一点没关系，offline 不服务用户</p>
<h2 id="How-to-handle-update-for-failure"><a href="#How-to-handle-update-for-failure" class="headerlink" title="How to handle update for failure"></a>How to handle update for failure</h2><p>Exponential back-off<br>success: crawl after 1 week<br>failure: crawl after 2 weeks<br>failure again: crawl after 4 weeks<br>…<br>保证了效率，不会总去爬失败的网页。</p>
<h2 id="How-to-handle-dead-cycle"><a href="#How-to-handle-dead-cycle" class="headerlink" title="How to handle dead cycle"></a>How to handle dead cycle</h2><p>One web has so many url, it will only crawl url in sina pages not others.<br>起始网页 seeds 链接多 新闻源网页<br>Use Quota! 为scheduler中每个网页提供一个限量</p>
<h2 id="Other-key-points"><a href="#Other-key-points" class="headerlink" title="Other key points"></a>Other key points</h2><p>inverted index 搜索引擎关键部分 查询基本不怎么用数据库, 效率低<br>网页之间有很多指向的关系，网页组成的节点<br>crawler 下载所有网页之后丢给GFS(效率大于DB), 拆开文章分成word,<br>inverted index 假的索引，查询引擎(query engine)<br>中文需要断句(word segmentation)<br>英文词态还原 likes-&gt;like<br>viterbi algorithm 分词算法<br>在query engine里做<br>bfs最好,dfs容易stackoverflow<br>crawler 抓完预渲染<br>多线程crawler<br>瓶颈在于加载网页<br>通过网页是否变化来推断timestamp<br>数据库实现队列<br>queue不应该只是先进先出<br>永远不要删数据！！！</p>
<hr>
<h1 id="TypeHead"><a href="#TypeHead" class="headerlink" title="TypeHead"></a>TypeHead</h1><h2 id="Scenario-1"><a href="#Scenario-1" class="headerlink" title="Scenario"></a>Scenario</h2><p>DAU 500m<br>Search: 4 <em> 6 </em> 500m = 12b(every user searches 6 times, types 4 letters)<br>QPS = 12b / 86400 = 138k<br>Peak QPS = 138k * 2 = 276k</p>
<h2 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h2><ol>
<li>QueryService</li>
<li>DataCollectionService</li>
</ol>
<h2 id="Storage-1"><a href="#Storage-1" class="headerlink" title="Storage"></a>Storage</h2><h3 id="For-QueryService"><a href="#For-QueryService" class="headerlink" title="For QueryService"></a>For QueryService</h3><p>数据库中like操作是非常expensive的，要用trie来进行优化<br>搜索引擎查询最好是key-value<br>Trie hashMap 效率 hashMap高 Trie省空间 性能差异<br>虽然expected time都是O(n)，但是trie的查找会在内存中跳来跳去<br>并不需要全部存完，可以只存top n的Words, 这个trie有in-memory的也有disk serialization的<br>当Trie太大了内存放不下的话，那么就需要把内存中trie的某些部分序列化之后存到磁盘中，要用的时候再反序列化取到内存中<br>一般就算是执行网页中的动态内容也会放在sandbox中的，不用担心会中毒。<br><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/Typehead%20structure.png?raw=true" alt="TypeHead"></p>
<h3 id="For-DataCollectionService"><a href="#For-DataCollectionService" class="headerlink" title="For DataCollectionService"></a>For DataCollectionService</h3><p>dataCollectionService offline 统计query<br>相当于把query的活分一部分给data collection去做，来加速query<br>从log data里统计信息的，可以用BigTable</p>
<h2 id="How-to-qualify-this-system"><a href="#How-to-qualify-this-system" class="headerlink" title="How to qualify this system"></a>How to qualify this system</h2><ol>
<li>response time </li>
<li>result quality</li>
</ol>
<h2 id="How-to-reduce-response-time"><a href="#How-to-reduce-response-time" class="headerlink" title="How to reduce response time"></a>How to reduce response time</h2><ol>
<li>cache result</li>
<li>pre-fetch</li>
</ol>
<h2 id="What-if-trie-gets-too-large"><a href="#What-if-trie-gets-too-large" class="headerlink" title="What if trie gets too large"></a>What if trie gets too large</h2><p>Sharding trie, 多个queryservice一起工作, 用consistent hashing来决定具体的string在哪个机器上。<br>trie sharding 不能用单词开头sharding 有可能一个上面特别多<br>prefic sharding<br>sharding 和 QPS 有关，和trie、hashmap无关</p>
<h2 id="How-to-reduce-size-of-log-file"><a href="#How-to-reduce-size-of-log-file" class="headerlink" title="How to reduce size of log file"></a>How to reduce size of log file</h2><p>Probalilistic Logging<br>就是每来一次搜索我就扔一次骰子(随机数)，如果扔到了特定的数字就log， 否则就忽略。<br>每个log文件的保留都要有个概率，比如1/1000，这样就能显著减少file量。</p>
<h2 id="爬虫的效率不影响搜索引擎的效率么？"><a href="#爬虫的效率不影响搜索引擎的效率么？" class="headerlink" title="爬虫的效率不影响搜索引擎的效率么？"></a>爬虫的效率不影响搜索引擎的效率么？</h2><p>只会影响搜索结果的时效性，但是不会影响到向用户返回结果的效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/04/trie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/04/trie/" itemprop="url">Trie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-05T01:30:16+08:00">
                2019-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>大年初一，凌晨四点醒了等待新年睡不着，就总结一下，Trie 这个结构提供了前缀查找的可靠方法，要实现的代码也挺多的，还是要时常写一写的，这里就总结一下常见的Trie的题目。</p>
<h1 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a>Implement Trie (Prefix Tree)</h1><p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">Implement Trie (Prefix Tree)</a><br>这个题就是标准要实现一个Trie的结构，作为一个模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean hasWord;</span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">        this.children = new TrieNode[26];</span><br><span class="line">        this.hasWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    TrieNode root;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Inserts a word into the trie. */</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                cur.children[wc[i] - &apos;a&apos;] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.hasWord = true;</span><br><span class="line">        return;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the trie. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.hasWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if there is any word in the trie that starts with the given prefix. */</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        char[] wc = prefix.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * Trie obj = new Trie();</span><br><span class="line"> * obj.insert(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Add-and-Search-Word-Data-structure-design"><a href="#Add-and-Search-Word-Data-structure-design" class="headerlink" title="Add and Search Word - Data structure design"></a>Add and Search Word - Data structure design</h1><p><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/description/" target="_blank" rel="noopener">Add and Search Word - Data structure design</a><br>这个题类似，不过要重写search函数，改为递归调用即可，注意加起始范围, 这个题还是多练练<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean hasWord;</span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">        this.children = new TrieNode[26];</span><br><span class="line">        this.hasWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Trie &#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        this.root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                cur.children[wc[i] - &apos;a&apos;] = new TrieNode();   </span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.hasWord = true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        return match(0, wc, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean match(int start, char[] wc,  TrieNode cur) &#123;</span><br><span class="line">        if (cur == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (wc[i] == &apos;.&apos;) &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">                    flag = flag || match(i + 1, wc, cur.children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                return flag;</span><br><span class="line">            &#125; else if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.hasWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class WordDictionary &#123;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    Trie root;</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        this.root = new Trie();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Adds a word into the data structure. */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        this.root.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        return root.search(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your WordDictionary object will be instantiated and called as such:</span><br><span class="line"> * WordDictionary obj = new WordDictionary();</span><br><span class="line"> * obj.addWord(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Word-Search-II"><a href="#Word-Search-II" class="headerlink" title="Word Search II"></a>Word Search II</h1><p><a href="https://leetcode.com/problems/word-search-ii/description/" target="_blank" rel="noopener">Word Search II</a><br>先建Trie, 再DFS，DFS过程中要用startsWith降低复杂度，同时注意去重，可以搜索成功之后把hasWord变为false，也可以trienode加一个成员变量string 然后置空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean hasWord;</span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">        this.children = new TrieNode[26];</span><br><span class="line">        this.hasWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Trie &#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                cur.children[wc[i] - &apos;a&apos;] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.hasWord = true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean startsWith(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        char[] wc = word.toCharArray();</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        for (int i = 0; i &lt; wc.length; i++) &#123;</span><br><span class="line">            if (cur.children[wc[i] - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[wc[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        boolean res = cur.hasWord;</span><br><span class="line">        cur.hasWord = false;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findWords(char[][] board, String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        Trie trie = new Trie();</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = board.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int m = board[0].length;</span><br><span class="line">        boolean[][] visited = new boolean[n][m];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                dfs(&quot;&quot;, trie, res, i, j, board, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(String word, Trie trie, List&lt;String&gt; res, int x, int y, char[][] board, boolean[][] visited) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length || visited[x][y]) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        word += board[x][y];</span><br><span class="line">        if (!trie.startsWith(word)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (trie.search(word)) &#123;</span><br><span class="line">            res.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = true;</span><br><span class="line">        dfs(word, trie, res, x + 1, y, board, visited);</span><br><span class="line">        dfs(word, trie, res, x - 1, y, board, visited);</span><br><span class="line">        dfs(word, trie, res, x, y + 1, board, visited);</span><br><span class="line">        dfs(word, trie, res, x, y - 1, board, visited);</span><br><span class="line">        visited[x][y] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/04/system-design-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/04/system-design-2/" itemprop="url">System Design 2 Design User System - DataBase & Memcache</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-04T23:29:29+08:00">
                2019-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/System-Design/" itemprop="url" rel="index">
                    <span itemprop="name">System Design</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Scenario-and-Services-想一想情景是什么，需要实现什么功能"><a href="#Scenario-and-Services-想一想情景是什么，需要实现什么功能" class="headerlink" title="Scenario and Services (想一想情景是什么，需要实现什么功能)"></a>Scenario and Services (想一想情景是什么，需要实现什么功能)</h1><p><strong>情景决定功能</strong></p>
<p><strong>A simple one will include these basic functions</strong></p>
<ol>
<li>User registration (用户注册) write op</li>
<li>LogIn (登陆)</li>
<li>Search for user information (查询) read op</li>
<li>Store friendship info</li>
</ol>
<p><strong>The number of write op and read op will determine the design of system. When we want to design a system common used by user(people). it will have more read op than write op. Vice versa for machine used system.</strong><br><strong>人用的读多写少，机器用的写多读少</strong></p>
<p><strong>DAU(Daily Active User)</strong><br><strong>QPS(Quries Per Seconds)</strong> 决定数据存储系统的选择<br><strong>一天的时间 86400s</strong> 为了计算方便可以 ~ 100k</p>
<p><strong>注册，登录，信息修改 QPS 约</strong> </p>
<ul>
<li>100M * 0.1 / 86400 ~ 100 </li>
<li>0.1 = 平均每个用户每天登录+注册+信息修改 </li>
<li>Peak = 100 * 3 = 300 3 为预估值</li>
</ul>
<p><strong>查询的QPS 约</strong></p>
<ul>
<li>100 M * 100 / 86400 ~ 100k</li>
<li>100 = 平均每个用户每天与查询用户信息相关的操作次数(查看好友，发信息，更新消息主页)</li>
<li>Peak = 100k * 3 = 300 k</li>
</ul>
<h2 id="DataBase-Choice-based-by-QPS"><a href="#DataBase-Choice-based-by-QPS" class="headerlink" title="DataBase Choice based by QPS"></a>DataBase Choice based by QPS</h2><ul>
<li>MySQL —— 1k (relation type)</li>
<li>MongoDB / Cassandra —— 10k (disk type)</li>
<li>Redis(数据持久化) / Memcached(非数据持久化) —— 100k ~ 1M (cache type)</li>
</ul>
<hr>
<ul>
<li>读多写少的系统一定要用cache进行优化</li>
<li>file system cpu client browser 都有cache</li>
<li>优化DB查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class UserService:</span><br><span class="line">    </span><br><span class="line">    def getUser(self, user_id):</span><br><span class="line">        user = cache.get(user_id)</span><br><span class="line">        if user:</span><br><span class="line">            return user</span><br><span class="line">        user = database.get(user_id)</span><br><span class="line">        cache.set(user_id, user)</span><br><span class="line">        return user</span><br><span class="line"></span><br><span class="line">    def setUser(self, user) &#123;</span><br><span class="line">        cache.delete(user.id)</span><br><span class="line">        database.set(user)    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Authentication-Service"><a href="#Authentication-Service" class="headerlink" title="Authentication Service"></a>Authentication Service</h2><h3 id="Session-amp-cookie"><a href="#Session-amp-cookie" class="headerlink" title="Session &amp; cookie"></a>Session &amp; cookie</h3><ol>
<li>用户login之后会创建Session对象（server端）</li>
<li>返回session_key值到browser</li>
<li>这个值被browser记录在cookie中</li>
<li>用户再次访问的时候会带上这个网站上所有的cookie（session_key）</li>
<li>服务器检测session_key有效就认为用户登录</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>SessionTable</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>session key</td>
<td>string</td>
<td>hash值 全局唯一 无规律</td>
</tr>
<tr>
<td>user_id</td>
<td>foreign key</td>
<td>指向 user table 用来找user</td>
</tr>
<tr>
<td>expired_at</td>
<td>timeStamp</td>
<td>什么时候过期</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>这个table存在哪里都可以的，存在database可以持久一点，cache的话速度快 如果单点故障就让全部用户重新登录就好</li>
</ul>
<hr>
<p><strong>读写都很多怎么办?</strong></p>
<ol>
<li>增加机器分摊流量</li>
<li>使用Redis(cache-through) 读写都快 Memecached(cache-aside)</li>
</ol>
<ul>
<li>cache-aside: DB 和 cache 通过web server 进行沟通 memcached + mysql</li>
<li>cache-through: server只和cache沟通，cache和DB沟通 redis(DB + Cache)</li>
</ul>
<hr>
<h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><h2 id="FriendShip-Service"><a href="#FriendShip-Service" class="headerlink" title="FriendShip Service"></a>FriendShip Service</h2><ol>
<li>存为一条信息 查询一次</li>
<li>存为两条信息 查询两次</li>
</ol>
<p><strong>NoSQL很多事都要自己去做，有transaction不能选择NoSQL</strong></p>
<h3 id="Example-Cassandra"><a href="#Example-Cassandra" class="headerlink" title="Example Cassandra"></a>Example Cassandra</h3><ol>
<li>row_key: hashKey</li>
<li>column_key: sorted enable range query 可以是复合值 query(row_key, column_start, column_end)</li>
<li>value: String 许多信息时 Serialization </li>
</ol>
<p><img src="https://github.com/wushangzhen/Useful-Pircture/blob/master/friendship.png?raw=true" alt="alt text" title="Friendship Example"></p>
<p><strong>user table 用SQL</strong></p>
<hr>
<h1 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h1><h2 id="Single-point-failure"><a href="#Single-point-failure" class="headerlink" title="Single point failure"></a>Single point failure</h2><ul>
<li>数据拆分 Sharding (NoSQL自带， MySQL不带)<br>  按照一定的规则，将数据拆分成不同的部分，保存在不同的机器上<br>  这样就算挂也不会导致网站 100% 不可用</li>
<li>数据备份 Replica<br>  通常的做法是一式三份(重要的事情“写”三遍)<br>  Replica 同时还能分摊读请求</li>
</ul>
<ul>
<li>vertical sharding 不同数据放到不同机器 </li>
<li>Horizontal Sharding 重点！！！普通的hash分配数据时添加机器会发生数据大迁移, 这个属于nonconsistent hashing</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/04/computer-system-elf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/04/computer-system-elf/" itemprop="url">Computer System 1 - Elf Info Reader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-04T23:29:13+08:00">
                2019-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-System/" itemprop="url" rel="index">
                    <span itemprop="name">Computer System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><h2 id="stat"><a href="#stat" class="headerlink" title="stat()"></a>stat()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;    </span><br><span class="line">#include &lt;sys/stat.h&gt;   </span><br><span class="line">int stat(</span><br><span class="line">　　const char *filename    //文件或者文件夹的路径</span><br><span class="line">　　, struct stat *buf      //获取的信息保存在内存中</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>把文件信息存到stat的结构体指针中, 成功return 0, 失败return -1</p>
<hr>
<h2 id="struct-stat"><a href="#struct-stat" class="headerlink" title="struct stat"></a>struct stat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct stat  </span><br><span class="line">&#123;   </span><br><span class="line">    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/  </span><br><span class="line">    ino_t       st_ino;     /* inode number -inode节点号*/    </span><br><span class="line">    mode_t      st_mode;    /* protection -保护模式?*/    </span><br><span class="line">    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/    </span><br><span class="line">    uid_t       st_uid;     /* user ID of owner -user id*/    </span><br><span class="line">    gid_t       st_gid;     /* group ID of owner - group id*/    </span><br><span class="line">    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/    </span><br><span class="line">    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/    </span><br><span class="line">    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/    </span><br><span class="line">    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/    </span><br><span class="line">    time_t      st_atime;   /* time of last access -最近存取时间*/    </span><br><span class="line">    time_t      st_mtime;   /* time of last modification -最近修改时间*/    </span><br><span class="line">    time_t      st_ctime;   /* time of last status change - */    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>常用的是 st_size 文件的大小, 修改时间等</p>
<hr>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><p><strong>将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值, 块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作, 其返回值为指向S的指针</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">void *memset(void *s,int ch, unsigned n);</span><br><span class="line"></span><br><span class="line">memset(&amp;elfData, 0, sizeof(elfData));</span><br><span class="line">// elfData 里面的指针也可以直接赋值成null</span><br></pre></td></tr></table></figure></p>
<p>用来清空或重置或初始化</p>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *path, int access, int mode)；</span><br></pre></td></tr></table></figure>
<ul>
<li>返回文件句柄, return -1 返回失败 由于第三个参数mode只有当access为O_CREAT的时候才有效，因此open的函数实现是一个可变参数函数</li>
<li>每个文件都属于自己的句柄，例如标准输入是0，标准输出是1，标准出错是2。</li>
<li>每打开一个文件就会返回句柄来操作这个文件，一般是从3开始，然后4,5,6一直下去。</li>
<li>close（fd）之后句柄就返回给系统，例如打开一个文件后fd是3，close之后再打开另外一个文件也还是3，但代表的文件不一样了</li>
<li>access O_RDONLY  1 只读;    O_WRONLY 2  只写;   O_RDWR  4  读写 </li>
</ul>
<hr>
<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h1><p>这个函数是这个作业的重点，要充分理解这个函数的作用, 有点妈卖批的感觉<br><a href="http://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">man page mmap()</a><br>在这里总结一下</p>
<ol>
<li>linux 的系统调用函数，为了让client和server之间的数据交流更快一点实现了内存映射的功能</li>
<li>一般来讲client和server之间要通过IPC(管道、消息队列)进行访问，数据需要拷贝四次(I/O操作)，输入文件-&gt;server-&gt;IPC-&gt;client-&gt;输出文件, mmap通过映射到内存，实现输入输出文件通过内存沟通, 代替了I/O操作，频繁读写有优势</li>
<li>将特殊文件进行匿名内存映射，为关联进程提供共享内存空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">       // addr 指定地址，通常设为NULL 或 0, 自动选址</span><br><span class="line">       // length 代表将文件的多大内存存到内存里</span><br><span class="line">       // prot 映射区域的保护方式。可以为以下几种方式的组合：</span><br><span class="line">            PROT_EXEC 映射区域可被执行</span><br><span class="line">            PROT_READ 映射区域可被读取</span><br><span class="line">            PROT_WRITE 映射区域可被写入</span><br><span class="line">            PROT_NONE 映射区域不能存取</span><br><span class="line">       // flags 影响映射区域的各种特性</span><br><span class="line">           MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享</span><br><span class="line">           MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，此区域作的任何修改都不会写回原来的文件内容</span><br><span class="line">       // fd 要映射文件的文件描述符, 文件句柄</span><br><span class="line">       // offset 偏移量，从文件哪个部分开始映射一般设为1</span><br><span class="line">       int munmap(void *addr, size_t length);</span><br><span class="line"></span><br><span class="line">       data = mmap(0, fileStats.st_size, PROT_READ, MAP_SHARED, fileNum, 0);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define handle_error(msg) \</span><br><span class="line">    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    char *addr;</span><br><span class="line">    int fd;</span><br><span class="line">    struct stat sb;</span><br><span class="line">    off_t offset, pa_offset;</span><br><span class="line">    size_t length;</span><br><span class="line">    ssize_t s;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 3 || argc &gt; 4) &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s file offset [length]\n&quot;, argv[0]);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[1], O_RDONLY);</span><br><span class="line">    if (fd == -1)</span><br><span class="line">        handle_error(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">    if (fstat(fd, &amp;sb) == -1)           /* To obtain file size */</span><br><span class="line">        handle_error(&quot;fstat&quot;);</span><br><span class="line"></span><br><span class="line">    offset = atoi(argv[2]);</span><br><span class="line">    pa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - 1);</span><br><span class="line">        /* offset for mmap() must be page aligned */</span><br><span class="line"></span><br><span class="line">    if (offset &gt;= sb.st_size) &#123;</span><br><span class="line">        fprintf(stderr, &quot;offset is past end of file\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (argc == 4) &#123;</span><br><span class="line">        length = atoi(argv[3]);</span><br><span class="line">        if (offset + length &gt; sb.st_size)</span><br><span class="line">            length = sb.st_size - offset;</span><br><span class="line">                /* Can&apos;t display bytes past end of file */</span><br><span class="line">    &#125; else &#123;    /* No length arg ==&gt; display to end of file */</span><br><span class="line">        length = sb.st_size - offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,</span><br><span class="line">                MAP_PRIVATE, fd, pa_offset);</span><br><span class="line">    if (addr == MAP_FAILED)</span><br><span class="line">        handle_error(&quot;mmap&quot;);</span><br><span class="line"></span><br><span class="line">    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);</span><br><span class="line">    if (s != length) &#123;</span><br><span class="line">        if (s == -1)</span><br><span class="line">            handle_error(&quot;write&quot;);</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, &quot;partial write&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(addr, length + offset - pa_offset);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="ELF-Data-Structure"><a href="#ELF-Data-Structure" class="headerlink" title="ELF Data Structure"></a>ELF Data Structure</h1><p><a href="http://man7.org/linux/man-pages/man5/elf.5.html" target="_blank" rel="noopener">man page for elf data</a><br>可执行文件的结构顺序如下：<br>ELF Header-&gt;Program Header table or Section Header Table or both<br>ELF在起始位置, ELFheader里面有program header 和 section header table的offset</p>
<h2 id="ELF-Header-Ehdr"><a href="#ELF-Header-Ehdr" class="headerlink" title="ELF Header(Ehdr)"></a>ELF Header(Ehdr)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    unsigned char e_ident[EI_NIDENT];</span><br><span class="line">    uint16_t      e_type;</span><br><span class="line">    uint16_t      e_machine;</span><br><span class="line">    uint32_t      e_version;</span><br><span class="line">    ElfN_Addr     e_entry;</span><br><span class="line">    ElfN_Off      e_phoff;</span><br><span class="line">    ElfN_Off      e_shoff;</span><br><span class="line">    uint32_t      e_flags;</span><br><span class="line">    uint16_t      e_ehsize;</span><br><span class="line">    uint16_t      e_phentsize;</span><br><span class="line">    uint16_t      e_phnum;</span><br><span class="line">    uint16_t      e_shentsize;</span><br><span class="line">    uint16_t      e_shnum;</span><br><span class="line">    uint16_t      e_shstrndx;</span><br><span class="line">&#125; ElfN_Ehdr;</span><br></pre></td></tr></table></figure>
<p>char == 1 byte == 16 bit </p>
<ul>
<li>e_ident: 包含怎么解析这个的信息，数组里面前四个必须是ELFMAG0、ELFMAG1、ELFMAG2、ELFMAG3，可以通过这个判断这个是不是一个ELF文件</li>
</ul>
<p>作业中header可以直接使用这个完成copy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(&amp;elfData, data, sizeof(Elf64_Ehdr));</span><br></pre></td></tr></table></figure></p>
<p>剩下的就是如何完成其他两个table的copy</p>
<ul>
<li>e_phentsize: This member holds the size in bytes of one entry in the file’s program header table; all entries are the same size.</li>
<li>e_phnum: This member holds the number of entries in the program header table.</li>
<li>e_shentsize: This member holds a sections header’s size in bytes.  A section header is one entry in the section header table;all entries are the same size.</li>
<li>e_shnum: This member holds the number of entries in the section header table.</li>
<li>e_phoff: This member holds the program header table’s file offset in bytes.</li>
<li>e_shoff: This member holds the section header table’s file offset in bytes.</li>
<li>e_shstrndx: This member holds the section header table index of the entry associated with the section name string table.If the file has no section name string table, this member holds the value SHN_UNDEF.  If the index of section name string table section is larger than or equal to SHN_LORESERVE (0xff00), this member holds SHN_XINDEX (0xffff) and the real index of the section name string table section is held in the sh_link member of the initial entry in section header table.  Otherwise, the sh_link member of the initial entry in section header table contains the value zero.</li>
</ul>
<hr>
<h2 id="Program-Header-Phdr"><a href="#Program-Header-Phdr" class="headerlink" title="Program Header(Phdr)"></a>Program Header(Phdr)</h2><p>An executable or shared object file’s program header table is an array of structures, each describing a segment or other information the system needs to prepare the program for execution.<br>告诉系统如何准备执行这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t   p_type;</span><br><span class="line">    uint32_t   p_flags;</span><br><span class="line">    Elf64_Off  p_offset;</span><br><span class="line">    Elf64_Addr p_vaddr;</span><br><span class="line">    Elf64_Addr p_paddr;</span><br><span class="line">    uint64_t   p_filesz;</span><br><span class="line">    uint64_t   p_memsz;</span><br><span class="line">    uint64_t   p_align;</span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void *calloc(size_t n, size_t size);</span><br><span class="line">elfData-&gt;programHeader = (Elf64_Phdr*)calloc(elfData-&gt;elfHeader.e_phnum, sizeof(Elf64_Phdr));</span><br><span class="line">有个疑问？sizeof(Elf64_Phdr) == e_phentsize ????</span><br><span class="line">类似malloc(), 不同是calloc已经初始化好了, 适合初始化数组</span><br><span class="line">通过e_phoff 找到起始位置, for循环memcpy</span><br><span class="line">char* pointer_offset = data + ret-&gt;elfHeader.e_phoff;</span><br><span class="line">for (int i = 0; i &lt; ret-&gt;elfHeader.e_phnum; i++) &#123;</span><br><span class="line">    memcpy(&amp;ret-&gt;programHeader[i], pointer_offset, sizeof(Elf64_Phdr));</span><br><span class="line">    pointer_offset += sizeof(Elf64_Phdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Section-Header-Shdr"><a href="#Section-Header-Shdr" class="headerlink" title="Section Header (Shdr)"></a>Section Header (Shdr)</h2><p>A file’s section header table lets one locate all the file’s sections<br>找到文件所有section</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t   sh_name;</span><br><span class="line">    uint32_t   sh_type;</span><br><span class="line">    uint64_t   sh_flags;</span><br><span class="line">    Elf64_Addr sh_addr;</span><br><span class="line">    Elf64_Off  sh_offset;</span><br><span class="line">    uint64_t   sh_size;</span><br><span class="line">    uint32_t   sh_link;</span><br><span class="line">    uint32_t   sh_info;</span><br><span class="line">    uint64_t   sh_addralign;</span><br><span class="line">    uint64_t   sh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<h3 id="Section-Name"><a href="#Section-Name" class="headerlink" title="Section Name"></a>Section Name</h3><p>老师给的数据结构需要存名字，所以在calloc的时候要多分一点内存，宏定义一个NAMEBUFFER = 100</p>
<ul>
<li>SHN_LORESERVE: This value specifies the lower bound of the range of reserved indices.</li>
<li>sh_link: This member holds a section header table index link, whose interpretation depends on the section type.</li>
<li>sh_name: This member specifies the name of the section.  Its value is an index into the section header string table section, giving the location of a null-terminated string.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int shNameStringIndex; // 找到namestring的index</span><br><span class="line">if (ret-&gt;elfHeader.e_shstrndx &gt;= SHN_LORESERVE) &#123; // 存的地方是不同的</span><br><span class="line">    shNameStringIndex = ret-&gt;sections[0].sectionHeader.sh_link; // 拿到section0 的link, 存在这里</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    shNameStringIndex = ret-&gt;elfHeader.e_shstrndx; // 存在这里 </span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; ret-&gt;elfHeader.e_shnum; i++) &#123;</span><br><span class="line">    memcpy(&amp;ret-&gt;sections[i].sectionHeader, pointer_offset, sizeof(Elf64_Shdr));    </span><br><span class="line">    pointer_offset += ret-&gt;elfHeader.e_shentsize;</span><br><span class="line">&#125;</span><br><span class="line">for (int j = 0; j &lt; ret-&gt;elfHeader.e_shnum; j++) &#123;</span><br><span class="line">    ret-&gt;sections[j].sectionName = strdup(data + ret-&gt;sections[shNameStringIndex].sectionHeader.sh_offset</span><br><span class="line">        + ret-&gt;sections[j].sectionHeader.sh_name); // strdup复制字符串(里面其实是地址)</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Elf Section build done&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="Symbol-List"><a href="#Symbol-List" class="headerlink" title="Symbol List"></a>Symbol List</h3><p>通过与sectionname的对比找到相应的section index，通过sectionheader的size和Elf64_Sym找到symbol list的size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (symTableIndex &gt; 0) &#123;</span><br><span class="line">   ret-&gt;otherSymbols.size = ret-&gt;sections[symTableIndex].sectionHeader.sh_size / sizeof(Elf64_Sym);</span><br><span class="line">   ret-&gt;otherSymbols.list = (ElfSymbol*)calloc(ret-&gt;otherSymbols.size, sizeof(Elf64_Sym) + NAME_BUFFER);</span><br><span class="line">   ptr = data + ret-&gt;sections[symTableIndex].sectionHeader.sh_offset;</span><br><span class="line">   for (int i = 0; i &lt; ret-&gt;otherSymbols.size; i++) &#123;</span><br><span class="line">       memcpy(&amp;ret-&gt;otherSymbols.list[i].symbol, ptr, sizeof(Elf64_Sym));    </span><br><span class="line">       ptr += sizeof(Elf64_Sym);</span><br><span class="line">       if (ret-&gt;otherSymbols.list[i].symbol.st_name == 0) &#123;</span><br><span class="line">           continue;    </span><br><span class="line">       &#125;</span><br><span class="line">       ret-&gt;otherSymbols.list[i].name = strdup(data + ret-&gt;sections[symTableNameIndex].sectionHeader.sh_offset</span><br><span class="line">           + ret-&gt;otherSymbols.list[i].symbol.st_name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Destroy-ELF-Data"><a href="#Destroy-ELF-Data" class="headerlink" title="Destroy ELF Data"></a>Destroy ELF Data</h1><h2 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(p);</span><br><span class="line">p = NULL;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/stack/" itemprop="url">Stack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-04T11:14:32+08:00">
                2019-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>LeetCode里面有很多关于stack的题都是一些非常巧妙的方法，尤其是单调栈的应用，在这里总结一下关于stack的难题。<br>关于stack最先想到的就是<a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">20. Valid Parentheses</a>, 这个是stack的基本应用，简单的就不说了我们直接来难题。</p>
<hr>
<h1 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h1><p><a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">Trapping Rain Water</a><br>这道题可以用双指针的方法或者stack的方法，这里呢我们先用stack的方法。<br>先构造一个单调递减的stack，每次拿到一个数先比较栈顶元素是否小于这个数，如果小于这个数就pop出来进行计算，这个单调递增stack里面应该存坐标因为算积水量的时候要用到index的。pop出来一个元素之后就要马上计算以它左右为边界的地方能存多少水，height[i]与stack顶的元素找最小值，计算水量，重复循环直到stack为空或者stack顶的元素大于height[i];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        if(height == null || height.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = height.length;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (stk.isEmpty()) &#123;</span><br><span class="line">                stk.push(i); // stk is empty we push element directly to stack</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (!stk.isEmpty() &amp;&amp; height[stk.peek()] &lt;= height[i]) &#123;</span><br><span class="line">                    int h = height[stk.pop()]; // get the height of current element to compute</span><br><span class="line">                    if (!stk.isEmpty()) &#123; // means it has leftbound</span><br><span class="line">                        int leftBound = height[stk.peek()];</span><br><span class="line">                        sum += (Math.min(leftBound, height[i]) - h) * (i - stk.peek() - 1); // compute water volumn</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(i); // push the index into stack</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Time Complexity and Space Complexity O(n)</span><br></pre></td></tr></table></figure>
<p><strong>注意stack一定是单调递减的, 不能有相等的, 存index挺关键的</strong></p>
<hr>
<h1 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a>Min Stack</h1><p><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">Min Stack</a><br>维持一个单调递减stack，stack栈顶一直维持所有的元素的最小值，每次加入的时候和栈顶元素进行判断，如果小于或等于栈顶元素或者stack为空的时候直接加入stack中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    Stack&lt;Integer&gt; stk1;</span><br><span class="line">    Stack&lt;Integer&gt; stk2;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        stk1 = new Stack&lt;&gt;();</span><br><span class="line">        stk2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stk1.push(x);</span><br><span class="line">        if (!stk2.isEmpty() &amp;&amp; stk2.peek() &lt; x) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        stk2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        int value = stk1.pop();</span><br><span class="line">        if (stk2.peek() == value) &#123;</span><br><span class="line">            stk2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stk1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        return stk2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack obj = new MinStack();</span><br><span class="line"> * obj.push(x);</span><br><span class="line"> * obj.pop();</span><br><span class="line"> * int param_3 = obj.top();</span><br><span class="line"> * int param_4 = obj.getMin();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Max-Stack"><a href="#Max-Stack" class="headerlink" title="Max Stack"></a>Max Stack</h1><p><a href="https://leetcode.com/problems/max-stack/description/" target="_blank" rel="noopener">Max Stack</a><br>这里需要维持一个单调递增stack等于记录每加入一个数之后最大值是多少，popmax的时候要得到递增stack里面的当前最大值，pop原始stack的值，然后再一个个的push进去，注意的点是两个stack里面元素数目是相同的，这个是这个题的关键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class MaxStack &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    Stack&lt;Integer&gt; stk1;</span><br><span class="line">    Stack&lt;Integer&gt; stk2;</span><br><span class="line">    public MaxStack() &#123;</span><br><span class="line">        stk1 = new Stack&lt;&gt;();</span><br><span class="line">        stk2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stk1.push(x);</span><br><span class="line">        if (!stk2.isEmpty() &amp;&amp; stk2.peek() &gt; x) &#123;</span><br><span class="line">            stk2.push(stk2.peek());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stk2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        stk2.pop();</span><br><span class="line">        return stk1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stk1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int peekMax() &#123;</span><br><span class="line">        return stk2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int popMax() &#123;</span><br><span class="line">        int value = stk2.peek();</span><br><span class="line">        Stack&lt;Integer&gt; tmp = new Stack&lt;&gt;();</span><br><span class="line">        while (stk1.peek() != value) &#123;</span><br><span class="line">            tmp.add(stk1.pop());</span><br><span class="line">            stk2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk1.pop();</span><br><span class="line">        stk2.pop();</span><br><span class="line">        while (!tmp.isEmpty()) &#123;</span><br><span class="line">            push(tmp.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MaxStack object will be instantiated and called as such:</span><br><span class="line"> * MaxStack obj = new MaxStack();</span><br><span class="line"> * obj.push(x);</span><br><span class="line"> * int param_2 = obj.pop();</span><br><span class="line"> * int param_3 = obj.top();</span><br><span class="line"> * int param_4 = obj.peekMax();</span><br><span class="line"> * int param_5 = obj.popMax();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Next-Greater-Element-I"><a href="#Next-Greater-Element-I" class="headerlink" title="Next Greater Element I"></a>Next Greater Element I</h1><p><a href="https://leetcode.com/problems/next-greater-element-i/description/" target="_blank" rel="noopener">Next Greater Element I</a><br>这个也是维持一个单调递减stack，每次加入一个比栈顶大的元素时要连续pop出来元素，这些比当前元素小的next greater element就是当前元素，用map记下来就好了，也很巧妙。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        for (int num : nums2) &#123;</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; stk.peek() &lt; num) &#123;</span><br><span class="line">                memo.put(stk.pop(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums1.length;</span><br><span class="line">        int[] res = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = memo.getOrDefault(nums1[i], -1);</span><br><span class="line">        &#125; </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h1><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="noopener">Largest Rectangle in Histogram</a><br>这个题也非常的巧妙，维持一个单调递增stack，每出现的元素比栈顶元素小的时候，需要进行计算，以stack中元素为边长到当前元素之间的面积，如果计算过程中stack为空说明这个在最后一个元素前面的元素都比当前元素大，计算面积即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        if (heights == null || heights.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int n = heights.length;</span><br><span class="line">        // 维持一个单调递增stack这样的话，就可以每次pop出来的时候根据当前坐标计算面积</span><br><span class="line">        // 注意最后压入-1进行所有的清算</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = (i == n) ? -1 : heights[i];</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; cur &lt;= heights[stk.peek()]) &#123;</span><br><span class="line">                int h = heights[stk.pop()];</span><br><span class="line">                int w = stk.isEmpty() ? i : i - stk.peek() - 1;</span><br><span class="line">                max = Math.max(max, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h1><p><a href="https://leetcode.com/problems/maximal-rectangle/description/" target="_blank" rel="noopener">Maximal Rectangle</a><br>这个题和之前那个题不同之处就是扩展到了二维，每行都要算一下largest rectangle而已，也是非常巧妙的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        // 这个题需要降维来解，用84题的方法，每一行进行计算，累计一下进行直方图的计算</span><br><span class="line">        if (matrix == null || matrix.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix.length;</span><br><span class="line">        int m = matrix[0].length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[m];</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                dp[j] = (matrix[i][j] == &apos;0&apos;) ? 0 : dp[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, helper(dp));</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    public int helper(int[] dp) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int n = dp.length;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = (i == n) ? -1 : dp[i];</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; cur &lt;= dp[stk.peek()]) &#123;</span><br><span class="line">                int h = dp[stk.pop()];</span><br><span class="line">                int w = stk.isEmpty() ? i : i - stk.peek() - 1;</span><br><span class="line">                max = Math.max(max, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Binary-Tree-Postorder-Traversal"><a href="#Binary-Tree-Postorder-Traversal" class="headerlink" title="Binary Tree Postorder Traversal"></a>Binary Tree Postorder Traversal</h1><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a><br>一开始我自己的想法是记录一下访问的上一个值和stack里peek值进行比较判断子树是否遍历完，然后看了一个discussion一个大神的解答，只能大喊卧槽了, 利用linkedlist 和 stack，遍历过程中运用addfirst把加入的顺序反过来，背这个就完事了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while (!stk.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stk.pop();</span><br><span class="line">            ans.add(0, cur.val);</span><br><span class="line">            if (cur.left != null) &#123;</span><br><span class="line">                stk.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur.right != null) &#123;</span><br><span class="line">                stk.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Basic-Calculator"><a href="#Basic-Calculator" class="headerlink" title="Basic Calculator"></a>Basic Calculator</h1><p><a href="https://leetcode.com/problems/basic-calculator/description/" target="_blank" rel="noopener">Basic Calculator</a><br>这个题也是一个相当好stack的应用，维持一个num，res，sign是这个题的关键，都是integer类型的，stack负责处理碰到括号的情况，把原先的res和sign都压到stack里面清零这些值，计算括号里面的值，得到新的res值，再pop出来原来的值进行计算，每次遇到加减号计算，所以最后出循环也要计算一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int sign = 1;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char c = sc[i];</span><br><span class="line">            if (&apos;0&apos; &lt;= c &amp;&amp; c &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                num = num * 10 + c - &apos;0&apos;;</span><br><span class="line">            &#125; else if (c == &apos;+&apos;) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                sign = 1;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else if (c == &apos;-&apos;) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                sign = -1;  </span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else if (c == &apos;(&apos;) &#123;</span><br><span class="line">                stk.push(res);</span><br><span class="line">                stk.push(sign);</span><br><span class="line">                num = 0;</span><br><span class="line">                res = 0;</span><br><span class="line">                sign = 1;</span><br><span class="line">            &#125; else if (c == &apos;)&apos;) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                int tempSign = stk.pop();</span><br><span class="line">                int tempRes = stk.pop();</span><br><span class="line">                res = tempRes + tempSign * res;</span><br><span class="line">                num = 0;</span><br><span class="line">                sign = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += sign * num;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Verify-Preorder-Sequence-in-Binary-Search-Tree"><a href="#Verify-Preorder-Sequence-in-Binary-Search-Tree" class="headerlink" title="Verify Preorder Sequence in Binary Search Tree"></a>Verify Preorder Sequence in Binary Search Tree</h1><p><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/description/" target="_blank" rel="noopener">Verify Preorder Sequence in Binary Search Tree</a><br>这个题也是用stack的典型例子，维持一个单调递减stack还有一个low值，这个low值维持的是当前元素到末尾的lowerbound，每次出现元素比栈顶元素大的时候就说明进入到了右子树，栈顶元素就相应变成lowbound，继续pop来找到右子树的位置，如果过程中low值大于了当前值，返回false, O(1)space的方法有点巧妙，暂时就先不在这篇讲了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean verifyPreorder(int[] preorder) &#123;</span><br><span class="line">        if (preorder == null || preorder.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        int low = Integer.MIN_VALUE;</span><br><span class="line">        for (int i : preorder) &#123;</span><br><span class="line">            if (low &gt;= i) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; i &gt;= stk.peek()) &#123;</span><br><span class="line">                low = stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Remove-Duplicate-Letters"><a href="#Remove-Duplicate-Letters" class="headerlink" title="Remove Duplicate Letters"></a>Remove Duplicate Letters</h1><p><a href="https://leetcode.com/problems/remove-duplicate-letters/description/" target="_blank" rel="noopener">Remove Duplicate Letters</a><br>这题也是用stack，先遍历字符串，记录哈希值，然后再次遍历一个一个加入stack中如果出现当前元素小于栈顶元素的情况那么就判断栈顶元素的memo值是否为0，不为0代表以后还会出现就先删掉，一直pop下去就行，维护一个visited，如果已经出现，就代表前方已经安排好了，挺巧妙的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicateLetters(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] memo = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            memo[s.charAt(i) - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] visited = new boolean[26];</span><br><span class="line">        Stack&lt;Character&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        char[] sc = s.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            memo[sc[i] - &apos;a&apos;]--;</span><br><span class="line">            if (visited[sc[i] - &apos;a&apos;]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stk.isEmpty() &amp;&amp; stk.peek() &gt; sc[i] &amp;&amp; memo[stk.peek() - &apos;a&apos;] &gt; 0) &#123;</span><br><span class="line">                visited[stk.peek() - &apos;a&apos;] = false;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(sc[i]);</span><br><span class="line">            visited[sc[i] - &apos;a&apos;] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!stk.isEmpty()) &#123;</span><br><span class="line">            sb.insert(0, stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a>Verify Preorder Serialization of a Binary Tree</h1><p><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/" target="_blank" rel="noopener">Verify Preorder Serialization of a Binary Tree</a><br>这个题利用stack不断删除叶节点，然后留到最后判断是不是只剩一个#了<br><img src="https://www.programcreek.com/wp-content/uploads/2016/04/verify-preorder-serialization-of-a-binary-tree-leetcode-java-730x468.jpg" alt="图示"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidSerialization(String preorder) &#123;</span><br><span class="line">        if (preorder == null || preorder.length() == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] strs = preorder.split(&quot;,&quot;);</span><br><span class="line">        int n = strs.length;</span><br><span class="line">        Stack&lt;String&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            String cur = strs[i];</span><br><span class="line">            while (cur.equals(&quot;#&quot;) &amp;&amp; !stk.isEmpty() &amp;&amp; stk.peek().equals(cur)) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                if (stk.isEmpty()) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.size() == 1 &amp;&amp; stk.peek().equals(&quot;#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/single-source-shortest-path/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/single-source-shortest-path/" itemprop="url">Graph Theory - Single Source Shortest Distance Path</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-02T13:54:52+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>很气，昨天做OA竟然出了一个Bellman Ford的单源最短路径的问题，虽然学过，但是java代码当时不会写，所以应该OA也挂了，后来总结了一下发现的确是算法的基础还不够牢固，虽然上过算法课但是只是明白了其中的皮毛，真的要掌握还是要多花时间写博客进行总结，做题不用多要的是熟练，我感觉还是陷入了刷题数量的误区忘记了遍数多才是王道，停止虚荣的刷题把！！！单源最短路径虽然考的不多但是还是要掌握的</p>
<p>大致的意思是，给一个带权值的无向或者有向图和一个源点，计算从这个源点出发所得到的到达每个顶点的路径，并让到达每个顶点的权值最少。</p>
<hr>
<h1 id="Bell-Ford-Algorithm"><a href="#Bell-Ford-Algorithm" class="headerlink" title="Bell Ford Algorithm"></a>Bell Ford Algorithm</h1><p>这个算法可以作用在负权值的情况，而Dijkstra算法则不行。现实生活中还是有负权值的存在的，而且负权值可能会构成一个负权值的环这样的话，其他的算法可能会让这个环的权值一直变小，陷入死循环。</p>
<p>输入G(V,E)</p>
<ol>
<li>初始化一个和V数量相同大小的数组dist[]，初始化为INF, 源点为0</li>
<li>计算最短距离，需要循环V - 1次, 边的顺序是随意的但每次都要用相同的顺序<ul>
<li>如果dist[v] &gt; dist[u] + weight, 更新dist[v] = dist[u] + weight</li>
</ul>
</li>
<li>结束之后，再重新跑一边每条边，如果还是出现dist[v] &gt; dist[u] + weight, 说明有负权值环</li>
</ol>
<p><strong>算法复杂度O(VE)</strong></p>
<p>一般的OA或者OJ图的输入会给许多个二元数组，比如[1, 2], 昨天见的那道题有所不同是两个数组city_from[0]—1 city_to[0] —2<br>但是一般的建图算法都是一样的，一个map存节点和邻接节点，另一个map存入度, 注意是有向图还是无向图<br>图初始化代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void function(int[] arr1, int[] arr2, int[] weight) &#123;</span><br><span class="line">    // suppose there is not a duplicate edge and it is non directinal edge</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        map.putIfAbsent(arr1[i], new ArrayList&lt;&gt;());</span><br><span class="line">        map.putIfAbsent(arr2[i], new ArrayList&lt;&gt;());</span><br><span class="line">        map.get(arr1[i]).add(arr2[i]);</span><br><span class="line">        map.get(arr2[i]).add(arr1[i]);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拿到这个map之后就等于拿到了G(V, E), 然后我们就可以进行BellMan-Ford, 当然了这个题不建图操作起来更简单一些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public static void bellmanFord(int source, int[] arrFrom, int[] arrTo, int[] weight, int number) &#123;</span><br><span class="line">        int[] dist = new int[number];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[source] = 0; </span><br><span class="line">        for (int i = 0; i &lt; number - 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; arrFrom.length; j++) &#123;</span><br><span class="line">                if (dist[arrFrom[j]] != Integer.MAX_VALUE &amp;&amp; dist[arrTo[j]] &gt; dist[arrFrom[j]] + weight[j]) &#123;</span><br><span class="line">                dist[arrTo[j]] = dist[arrFrom[j]] + weight[j];    </span><br><span class="line">                &#125; </span><br><span class="line">                if (dist[arrTo[j]] != Integer.MAX_VALUE &amp;&amp; dist[arrFrom[j]] &gt; dist[arrTo[j]] + weight[j]) &#123;</span><br><span class="line">                dist[arrFrom[j]] = dist[arrTo[j]] + weight[j];    </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查负环需要再跑一下上面的算法</span><br><span class="line">        for (int i = 0; i &lt; dist.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;index: %d, dist[i]: %d\n&quot;, i, dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arrFrom = &#123;0, 0, 1, 3, 1, 2&#125;;</span><br><span class="line">        int[] arrTo = &#123;1, 2, 3, 4, 4, 4&#125;;</span><br><span class="line">        int[] weight = &#123;1, 2, 2, 1, 1, 1&#125;;</span><br><span class="line">        bellmanFord(0, arrFrom, arrTo, weight, 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无向图其实就是有向图</strong><br>这么简单都没做出来，洗洗睡吧</p>
<p><img src="https://cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm.jpg" alt="example"><br><a href="https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/" target="_blank" rel="noopener">参考资料</a></p>
<hr>
<h1 id="Dijkstra-Algorithm"><a href="#Dijkstra-Algorithm" class="headerlink" title="Dijkstra Algorithm"></a>Dijkstra Algorithm</h1><p>这个算法举个leetcode的题为例子<br><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" target="_blank" rel="noopener">787. Cheapest Flights Within K Stops</a><br>题意是给你一个图每个edge有weights找到最多k stops的最便宜的方案。<br>就是要找到从起点出发的每个点的最短路径，在计算的过程中看符不符合要求。<br>如果需要构造新的class的话先构造新的class，把源点压入queue中，每次poll出来最小的，这个值就是最后确定的值，遍历它的所有邻接节点如果没有访问过就加入queue, 直到queue里不存在东西。<br>出现三元组的时候可以通过建立<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map</span><br></pre></td></tr></table></figure></p>
<p>来分别建立起点终点权值之间的关系.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    int num;</span><br><span class="line">    int weight;</span><br><span class="line">    public Point(int num, int weight) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">        this.weight = weight;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int[][] weights, int n, int src) &#123;</span><br><span class="line">    int[] dist = new int[n];    </span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; topo = new HashMap&lt;&gt;();</span><br><span class="line">    //初始化</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        topo.put(i, new HashMap&lt;&gt;());    </span><br><span class="line">    &#125;</span><br><span class="line">    for (int[] weight : weights) &#123;</span><br><span class="line">        topo.get(weight[0]).put(weight[1], weight[2]);    </span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Point&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; (a.weight - b.weight));</span><br><span class="line">    q.add(new Point(src, 0));</span><br><span class="line">    while (!q.isEmpty()) &#123;</span><br><span class="line">        Point p = q.poll();</span><br><span class="line">        if (dist[p.num] == Integer.MAX_VALUE) &#123;</span><br><span class="line">            dist[p.num] = p.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : topo.get(p.num).entrySet&lt;&gt;()) &#123;</span><br><span class="line">            if (dist[entry.getKey()] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                q.add(new Point(entry.getKey(), entry.getValue() + p.weight));    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h1><p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" target="_blank" rel="noopener">787. Cheapest Flights Within K Stops</a><br><a href="https://leetcode.com/problems/network-delay-time/description/" target="_blank" rel="noopener">743. Network Delay Time</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/time-complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/time-complexity/" itemprop="url">Algorithm——Complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-30T17:59:50+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="时间复杂度（Time-Complexity）"><a href="#时间复杂度（Time-Complexity）" class="headerlink" title="时间复杂度（Time Complexity）"></a>时间复杂度（Time Complexity）</h1><ul>
<li>O(logN)的算法几乎可以确定是二分法，如果一个算法的暴力解法的时间复杂度为O(N)，继续优化的结果一般只能是O(logn)， 一般不会考察O(1)的解法在面试的时候。</li>
</ul>
<ul>
<li><blockquote>
<p>一个算法的运行时间与其所要执行的语句的数量成正比，而所要执行的语句与问题规模正相关。因此算法的时间复杂度可以表示为一个与问题规模 N 相关的多项式。</p>
</blockquote>
</li>
<li>只保留最高次项作为时间复杂度的值，舍去系数、其他次项等。</li>
</ul>
<h1 id="常见的算法时间复杂度（背诵）"><a href="#常见的算法时间复杂度（背诵）" class="headerlink" title="常见的算法时间复杂度（背诵）"></a>常见的算法时间复杂度（背诵）</h1><div class="table-container">
<table>
<thead>
<tr>
<th>复杂度</th>
<th style="text-align:right">对应的算法</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(1)</td>
<td style="text-align:right">位运算</td>
<td style="text-align:center">这个复杂度一般不会考</td>
</tr>
<tr>
<td>O(logn)</td>
<td style="text-align:right">二分法，倍增法，快速幂算法，辗转相除法</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>O(n)</td>
<td style="text-align:right">枚举法，双指针算法，单调栈算法，KMP算法、Rabin Karp，Manacher’s Algorithm</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>O(nlogn)</td>
<td style="text-align:right">快速排序，归并排序，堆排序</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>O(n<sup>2</sup>)</td>
<td style="text-align:right">枚举法，动态规划，Dijkstra</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>O(n<sup>3</sup>)</td>
<td style="text-align:right">枚举法，动态规划，Floyd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>O(2<sup>n</sup>)</td>
<td style="text-align:right">与组合有关的搜索问题</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>O(n!)</td>
<td style="text-align:right">与排列有关的搜索问题</td>
</tr>
</tbody>
</table>
</div>
<p>例如，给定一个已经排序的数组，现在有多次询问，每次询问一个数字是否在这个数组中，返回True or False.</p>
<ul>
<li>方法1： 每次扫描一遍数组，查看是否存在。 这个方法，每次查询的时间复杂度是: O(n)。</li>
</ul>
<ul>
<li>方法2：二分法：O(logn)。</li>
<li>方法3：存入Hashset：O(1)。</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">   sum++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倍增法 sum=log(n), 循环了log(n)次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">1</span>; j &lt;= n; j *= <span class="number">2</span>)&#123;</span><br><span class="line">      sum++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(nlogn)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibo</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibo(n - <span class="number">1</span>) + Fibo(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">O(2<sup>/frac{n}{2}</sup>) ~ O(2<sup>n</sup>)</script><p>计算时间复杂度的上界：</p>
<script type="math/tex; mode=display">F(n) = F(n - 1) + F(n - 2) < 2 * F(n - 1)</script><p>时间复杂度的上界为：</p>
<script type="math/tex; mode=display">< T(n) = 2 * T(n - 1) + O(1) = O(2^n)</script><p>时间复杂度的下界为：</p>
<script type="math/tex; mode=display">> T(n) = 2 * T(n - 2) + O(1) = O(2 ^ /frac{n}{2})</script><p><a href="https://www.cnblogs.com/33debug/p/6848330.html" target="_blank" rel="noopener"><font color="red">Fibo算法分析</font></a><br><strong> 注意这个是结果每次都要求的 </strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] F = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">F[<span class="number">0</span>] = F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (F[n] != <span class="number">0</span>) <span class="keyword">return</span> F[n];</span><br><span class="line">    F[n] = Fibo(n<span class="number">-1</span>) + Fibo(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> F[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>O(n)<br><strong> 这个结果用F[n]记录，所以时间复杂度是不同的 </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[i] &lt; window) &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(n)<br>典型的 双指针算法，[i, j)滑动窗口的两端，大家一定要记住，数循环次数是一个偷懒的时间复杂度计算方法，却不是最准确的时间复杂度计算方法。时间复杂度的定义，是程序总共执行的语句数目的数量级。在这个代码中，执行次数最多的是 j++ 这个循环主体。而这个循环体不会被执行O(n<sup>2</sup>)次，因为 j 在每次 i 循环的时候，不会被重置到 i 或者 0 的位置开始重新计算。j一直是自顾自的单向递增，那么一旦某一次 while 循环使得 j++ 执行了 n 次以后，while 循环就再也进不去了。因此总共的执行次数是O(n+n)=O(n)。</p>
<h1 id="T-函数推导法"><a href="#T-函数推导法" class="headerlink" title="T 函数推导法"></a>T 函数推导法</h1><p><strong> 二分法的T函数公式 </strong><br>$ T(n) = T(n/2) + O(1) $<br>T(n) : 求处理问题规模为n的数据时间复杂度是多少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = T(n/2) + O(1)</span><br><span class="line">     = T(n/4) + O(1) + O(1)</span><br><span class="line">     = T(n/8) + O(1) * 3</span><br><span class="line">     = T(n/16) + O(1) * 4</span><br><span class="line">     …</span><br><span class="line">     = T(1) + O(1) * logn</span><br><span class="line">     = O(logn)</span><br></pre></td></tr></table></figure></p>
<p>一些性质：</p>
<ol>
<li>T(1) = O(1)</li>
<li>k*O(n) = O(kn)</li>
<li>O(n) + O(m) = O(n+m)(同阶的不可以代替)</li>
</ol>
<h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><h3 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (n &gt; 1) &#123;</span><br><span class="line">   这里执行一个使用 O(n) 的算法，将 n 的规模缩小一半</span><br><span class="line">   n = n / 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$ T(n) = T(n/2) + O(n) $<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = T(n/2) + O(n)</span><br><span class="line">     = T(n/4) + O(n/2) + O(n)</span><br><span class="line">     = T(n/8) + O(n/4) + O(n/2) + O(n)</span><br><span class="line">     = …</span><br><span class="line">     = T(1) + O(1) + O(2) + … O(n/2) + O(n)</span><br><span class="line">     = O(1 + 2 + 4 .. + n/2 + n)</span><br><span class="line">     = O(2n) = O(n)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong> O(1 + 2 + 4 … + n/2 + n) = O(n)</strong> 带入1024计算然后加1可以得到结果为2047 = 2 * 1024 - 1  = O(2n) = O(n)。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shangzhen Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shangzhen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T00:37:56+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Shangzhen Wu</p>
              <p class="site-description motion-element" itemprop="description">This is a personal learning blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shangzhen Wu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
